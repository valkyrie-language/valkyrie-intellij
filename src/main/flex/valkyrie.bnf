{
    parserClass = "yggdrasil.psi.parser.YggdrasilParser"
    parserUtilClass = "valkyrie.psi.ParserExtension"

    extends = "valkyrie.psi.ValkyrieElement"

    psiClassPrefix = "Valkyrie"
    psiImplClassSuffix = "Node"
    psiPackage = "yggdrasil.psi.node"
    psiImplPackage = "yggdrasil.psi.node"

    elementTypeHolderClass = "valkyrie.psi.ValkyrieTypes"
    elementTypeClass = "valkyrie.psi.ValkyrieElementType"
    tokenTypeClass = "valkyrie.psi.ValkyrieTokenType"

    psiImplUtilClass = "yggdrasil.psi.node.YggdrasilPsiExtension"

    tokens = [
        // comment
        COMMENT_LINE = "Comment"
        COMMENT_BLOCK = "Comment Block"

        // literal
        URL = "Url"
        SYMBOL    = "Symbol"
        ESCAPED   = "\escaped"
        INTEGER   = "<<INTEGER>>"

        REFERENCE = "$Symbol"

        SELECTION_LINE = "SELECTION_LINE"


        KW_GRAMMAR = "grammar"
        KW_USING = "using"
        KW_GROUP = "group"
        KW_CLASS = "class"
        KW_UNION = "union"
        KW_CLIMB = "climb"
        KW_IMPORT = "import"
        KW_AS = "as"
        KW_MACRO = "macro"

		VERSION = "<<semver>>"
        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ANGLE_L = '<'
        ANGLE_R = '>'
        OP_REMARK = '^'
        BIND = '='
        COLON = ':'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        OP_MANY = '*'
        AT = '@'
        TO = "->"
        HYPHEN = "-"
        SLASH = '/'
        OP_OR = '|'
        OP_CONCAT = '~'
        PLACE_HOLDER = "_"
//      SPACE='regexp:\s+'
//      ANY = 'regexp:.'

    ]
}

// https://github.com/bytecodealliance/fluent/blob/master/spec/fluent.ebnf
root ::= statements*
private statements ::=
    declare-namespace
  | using
  | declare-flags
  | declare-enumerate
  | declare-unite
  | declare-class
  | declare-union
  | declare-interface
  | declare-imply
  | declare-function
  | SEMICOLON
// === grammar statement ===
declare-namespace ::= annotations KW_NAMESPACE namepath-free {
	pin = 2
    mixin = "valkyrie.psi.mixin.MixinNamespace"
}
// === class statement ===
using ::= annotations KW_USING identifier-free (DOT (OP_MANY | using-body))? {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinUsing"
}
using-body ::= BRACE_L using-term* BRACE_R;
using-term ::=
    using-alias
  | SEMICOLON
  | COMMA
using-alias ::= key KW_AS identifier-free;
// === class statement ===
declare-class ::= annotations KW_CLASS identifier-free class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinClass"
    methods=[highlight createLookup]
}
class-body ::= BRACE_L class-item* BRACE_R;
class-item ::=
    declare-method
  | declare-field
  | SEMICOLON
  | COMMA
// === class field statement ===
declare-field ::= annotations identifier-free type-hint? default-value? {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinField"
    methods=[highlight]
}
type-hint     ::= COLON type-expression;
default-value ::= EQUAL expression;
// === class method statement ===
declare-method ::= annotations identifier-free parameter-body return-type? effect-type? function-body? {
    pin = 3
    mixin = "valkyrie.psi.mixin.MixinMethod"
    methods=[highlight]
}
// === union statement ===
declare-union ::= annotations KW_UNITE identifier OP_REMARK? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinUnion"
    methods=[highlight createLookup]
}
// === enumerate statement ===
declare-flags ::= annotations KW_FLAGS identifier-free enumerate-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinFlags"
    methods=[highlight createLookup]
}
declare-enumerate ::= annotations KW_ENUMERATE identifier-free enumerate-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinEnumerate"
    methods=[highlight createLookup]
}
enumerate-body ::= BRACE_L enumerate-item* BRACE_R;
enumerate-item ::=
    declare-semantic
  | SEMICOLON
  | COMMA
declare-semantic ::= annotations identifier-free default-value? {
    mixin = "valkyrie.psi.mixin.MixinSemantic"
    methods=[highlight]
}
// === union statement ===
declare-unite ::= annotations KW_UNITE identifier OP_REMARK? union-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinUnite"
    methods=[highlight createLookup]
}
union-body ::= BRACE_L union-variant* BRACE_R;
union-variant ::= OP_OR expression tag-branch? {
    mixin = "valkyrie.psi.mixin.MixinUnionItem"
}
tag-branch ::= HASH identifier-free;
// === group statement ===
declare-interface ::= annotations KW_INTERFACE identifier-free? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinInterface"
    methods=[highlight createLookup]
}
declare-imply ::= annotations KW_IMPLY identifier-free class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinImply"
    methods=[highlight]
}
/// === function definition ===
declare-function ::= annotations KW_FUNCTION identifier-free parameter-body return-type? effect-type? function-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinFunction"
    methods=[highlight createLookup]
}
parameter-body ::= PARENTHESIS_L (parameter-item (COMMA parameter-item)* COMMA?)? PARENTHESIS_R;
parameter-item ::= identifier type-hint? default-value? {

}
function-body ::= BRACE_L function-item* BRACE_R;
function-item ::=
    expression
  | SEMICOLON;
return-type  ::= (OP_TO|COLON) type-expression;
effect-type  ::= SLASH type-expression;
// === function statement ===
function-call ::= namepath tuple? {
    pin = 1
}
macro-call    ::= AT namepath tuple? {

}
// === expression statement ===
expression ::= term (infix term)* {

};
term ::= prefix* atomic suffix* {

}
prefix ::= OP_BANG;
infix ::= OP_AND;
suffix ::= OP_BANG | OP_AND_THEN;
// === expression statement ===
type-expression ::= type-term (type-infix type-term)* {

};
type-term ::= type-prefix* type-atomic type-suffix* {

}
type-prefix ::= OP_NOT;
type-infix ::= OP_CONCAT;
type-suffix ::= OP_OPTIONAL;
type-atomic ::= identifier-free;

generic ::= GENERIC_L GENERIC_R;

// === atomic statement ===
atomic ::=
    PARENTHESIS_L expression PARENTHESIS_R
  | macro-call
  | function-call
  | namepath
  | string
  | number
  | ordinal-range
  | offset-range
// === atomic statement ===
ordinal-range ::= BRACE_L (range-item (COMMA range-item)? COMMA?) BRACE_R;
offset-range  ::= OFFSET_L (range-item (COMMA range-item)? COMMA?) OFFSET_R;
range-item ::= range-index
             | range-lower COLON range-upper?
             | range-lower COLON COLON range-step?
             | range-lower COLON range-upper COLON range-step?
             | COLON range-upper?
             | COLON COLON range-step?
             | COLON range-upper COLON range-step?
range-lower ::= expression;
range-upper ::= expression;
range-step  ::= expression;
range-index ::= expression;

string ::= TEXT_SINGLE | TEXT_DOUBLE {
    mixin = "valkyrie.psi.mixin.MixinString"
}
// === atomic statement ===
key      ::= identifier-free;
value    ::= tuple | string;
pair     ::= key COLON value {
//    mixin = "yggdrasil.psi.mixin.MixinTuple"
}
tuple    ::= PARENTHESIS_L PARENTHESIS_R
  | PARENTHESIS_L argument COMMA PARENTHESIS_R
  | PARENTHESIS_L (argument (COMMA argument)+ COMMA?)? PARENTHESIS_R
{
  //    mixin = "yggdrasil.psi.mixin.MixinTuple"
}
argument-body ::= PARENTHESIS_L (argument (COMMA argument)* COMMA?)? PARENTHESIS_R;
argument ::= (identifier-free COLON)? value {

}
number ::= INTEGER {
//    mixin = "yggdrasil.psi.mixin.MixinNumber"
}
// === annotation statement ===
annotations ::= attribute* modifier*
modifier    ::= identifier !(COMMA|SEMICOLON|EQUAL|COLON|PARENTHESIS_L|BRACE_R) {
    mixin = "valkyrie.psi.mixin.MixinModifier"
}
attribute   ::= HASH namepath argument-body? {
	pin = 1
    mixin = "valkyrie.psi.mixin.MixinAttribute"
    methods=[highlight]
}
// === identifiers ===
namepath      ::= identifier ((DOT) identifier)* {

}
namepath-free ::= identifier ((DOT) identifier)* {
    extends = namepath
}
identifier           ::= SYMBOL | SYMBOW_RAW {
    mixin = "valkyrie.psi.mixin.MixinIdentifier"
    methods=[highlight]
}
identifier-free      ::= SYMBOL | SYMBOW_RAW | KW_MACRO | KW_CLASS | KW_UNION | KW_GROUP | KW_GRAMMAR | KW_IMPORT | KW_AS | KW_CLIMB {
    extends = identifier
}
