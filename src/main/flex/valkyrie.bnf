{
    parserClass = "valkyrie.psi.parser.YggdrasilParser"
    parserUtilClass = "valkyrie.psi.ParserExtension"

    extends = "valkyrie.psi.ValkyrieElement"

    psiClassPrefix = "Valkyrie"
    psiImplClassSuffix = "Node"
    psiPackage = "valkyrie.psi.node"
    psiImplPackage = "valkyrie.psi.node"

    elementTypeHolderClass = "valkyrie.psi.ValkyrieTypes"
    elementTypeClass = "valkyrie.psi.ValkyrieElementType"
    tokenTypeClass = "valkyrie.psi.ValkyrieTokenType"

    psiImplUtilClass = "valkyrie.psi.node.YggdrasilPsiExtension"

    tokens = [
        // comment
        COMMENT_LINE = "Comment Line"
        COMMENT_BLOCK = "Comment Block"

        // literal
        SYMBOL    = "Symbol"
        ESCAPED   = "\escaped"
        INTEGER   = "<<INTEGER>>"

        REFERENCE = "$Symbol"

        SELECTION_LINE = "SELECTION_LINE"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ANGLE_L = '<'
        ANGLE_R = '>'

        EQUAL = '='
        COLON = ':'
        NAME_SPLIT = '∷'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        ANY_LIST = '‥'
        ANY_DICT = '…'

        OP_LLL = "⋘"
        OP_GGG = "⋙"
        OP_LL = "≪"
        OP_GG = "≫"
    ]
}


root ::= statements*
private statements ::= declare-namespace
    | using-statement
    | declare-type
    | declare-flags
    | declare-enums
    | declare-unite
    | declare-class
    | declare-union
    | declare-trait
    | declare-imply
    | declare-function
    | declare-mezzo
    | declare-macro
    | declare-component
    | declare-singleton
    | declare-neural
    | block-statement
private block-statement ::= SEMICOLON
    | let-statement
    | attribute-above
    | control-statement
    | expression-root
// === grammar statement ===
declare-namespace ::= annotations KW_NAMESPACE namepath-auto {
	pin = 2
    mixin = "valkyrie.psi.mixin.MixinNamespace"
}
// === class statement ===
using-statement ::= annotations KW_USING (using-body|using-term) {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinUsing"
}
using-term ::= SEMICOLON | COMMA
    | using-any      // using
    | using-alias    // using
    | using-block    // using
    | namepath-auto  // using
using-any     ::= (namepath-auto using-dot?) STAR using-exclude?
using-exclude ::= KW_EXCLUDE (identifier|BRACE_L (identifier (COMMA identifier)* COMMA?) BRACE_R)
using-block   ::= namepath-auto using-dot? using-body
using-body    ::= BRACE_L using-term* BRACE_R;
using-alias   ::= identifier KW_AS identifier;
private using-dot ::= DOT|NAME_SPLIT|OP_DIV
// infer T { where T: Show }
// imply List<T> { show_list() }
declare-infer ::= annotations KW_INFER (identifier (COMMA identifier)* COMMA?)? infer-body {
    pin = 2
}
infer-body ::= BRACE_L infer-item* BRACE_R;
infer-item ::= SEMICOLON
    | declare-where
// where T: Show, X: Show
declare-where   ::= KW_WHERE COLON? where-term* {
    pin = 1
}
where-term      ::= COMMA | SEMICOLON
    | where-condition;
where-condition ::= annotations type-term type-hint? default-type?;
// === type statement ===
declare-type ::= annotations KW_TYPE (type-alias|type-function) {
    pin = 2
}
// type A = B
type-alias   ::= identifier declare-infer? EQUAL type-expression;
// type A() -> B { }
type-function ::= declare-infer? identifier parameter-body return-type? block-body;
// === class statement ===
declare-class ::= declare-infer? annotations KW_CLASS identifier declare-generic? class-inherit? type-hint? class-body {
    pin = 3
    mixin = "valkyrie.psi.mixin.MixinClass"
}
declare-component ::= annotations KW_COMPONENT identifier declare-generic? class-inherit? type-hint? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinComponent"
}
declare-singleton ::= annotations KW_SINGLETON identifier declare-generic? class-inherit? type-hint? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinSingleton"
}
declare-neural ::= annotations KW_NEURAL identifier declare-generic? class-inherit? type-hint? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinNeural"
}
class-inherit ::= PARENTHESIS_L (inherit-item (COMMA inherit-item)* COMMA?)? PARENTHESIS_R;
inherit-item  ::= (annotations identifier COLON)? type-expression {
    mixin = "valkyrie.psi.mixin.MixinClassInherit"
}
// === class body ===
class-body ::= BRACE_L class-item* BRACE_R;
private class-item ::= SEMICOLON | COMMA
    | associated-type
    | declare-domain
    | declare-method
    | declare-field
// === class field statement ===
declare-field ::= annotations identifier-free type-hint? default-value? {
    mixin = "valkyrie.psi.mixin.MixinField"
}
type-hint     ::= COLON type-expression {
    mixin = "valkyrie.psi.mixin.MixinTypeHint"
}
default-value ::= EQUAL expression-root;
default-type  ::= EQUAL type-expression;
// === class method statement ===
declare-method ::= annotations KW_FUNCTION? identifier-free declare-infer? parameter-body return-type? block-body? {
    mixin = "valkyrie.psi.mixin.MixinMethod"
}
// === class domain statement ===
declare-domain ::= annotations identifier class-body {
    mixin = "valkyrie.psi.mixin.MixinDomain"
}
// === union statement ===
declare-union ::= annotations KW_UNION identifier class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinUnion"
}
// === flags statement ===
declare-flags ::= annotations KW_FLAGS identifier-free class-inherit? (EQUAL type-atomic)? flags-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinFlags"
}
flags-body ::= BRACE_L flags-item* BRACE_R;
private flags-item ::= SEMICOLON | COMMA
    | declare-method
    | declare-domain
    | declare-semantic
declare-semantic ::= annotations identifier (EQUAL expression)? {
    mixin = "valkyrie.psi.mixin.MixinSemantic"
}
// === enums statement ===
declare-enums ::= annotations KW_ENUMERATE identifier class-inherit? (EQUAL type-atomic)? flags-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinEnumerate"
}
// === union statement ===
declare-unite ::= declare-infer? annotations KW_UNITE identifier declare-infer? unite-body {
    pin = 3
    mixin = "valkyrie.psi.mixin.MixinUnite"
}
unite-body ::= BRACE_L unite-item* BRACE_R;
private unite-item ::= SEMICOLON | COMMA
    | declare-method
    | declare-variant
declare-variant ::= annotations identifier class-body? {
    mixin = "valkyrie.psi.mixin.MixinVariant"
}
// === group statement ===
declare-trait ::= annotations KW_TRAIT identifier (trait-alias|trait-define) {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinTrait"
}
/// trait A = C + D
trait-alias ::= EQUAL type-expression {
    pin = 1
//    mixin = "valkyrie.psi.mixin.MixinTraitAlias"
}
/// trait A: B { ... }
trait-define ::= type-hint? declare-infer? class-body {
//    pin = 2
//    mixin = "valkyrie.psi.mixin.MixinTraitAlias"
}
associated-type ::= annotations KW_TYPE identifier (EQUAL type-expression)? {
    pin = 2
}
// impl trait for class
declare-imply ::= annotations KW_IMPLY declare-infer? (
    // impl class: trait
    namepath generic-call-free? COLON type-expression
    // impl trait for class
  | type-expression KW_FOR namepath generic-call-free?
) class-body
{
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinImply"
}
// === generic statement ===
declare-generic ::=
    NAME_SPLIT? GENERIC_L (generic-parameter (COMMA generic-parameter)* COMMA?)? GENERIC_R
  | NAME_SPLIT? ANGLE_L   (generic-parameter (COMMA generic-parameter)* COMMA?)? ANGLE_R
{

}
generic-parameter ::= annotations identifier type-hint? default-type? {
    mixin = "valkyrie.psi.mixin.MixinTypeParameter"
}
/// === term function definition ===
declare-function ::= annotations KW_MICRO declare-infer? identifier parameter-body return-type? block-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinDeclareFunction"
}
/// === type function definition ===
declare-mezzo ::= annotations KW_MEZZO declare-infer? identifier parameter-body return-type? block-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinDeclareMezzo"
}
/// === expression function definition ===
declare-macro ::= annotations KW_MACRO declare-infer? identifier parameter-body return-type? block-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinDeclareMacro"
}
parameter-body ::= PARENTHESIS_L (parameter-term (COMMA parameter-term)* COMMA?)? PARENTHESIS_R;
private parameter-term ::= ANGLE_L | ANGLE_R
    | parameter-dict
    | parameter-list
    | parameter-item
parameter-item ::= annotations parameter-kind? identifier-free type-hint? default-value? {
    mixin = "valkyrie.psi.mixin.MixinValueParameter"
}
parameter-list ::= annotations ANY_LIST identifier-free? type-hint? default-value? {

}
parameter-dict ::= annotations ANY_DICT identifier-free? type-hint? default-value? {

}
parameter-kind ::= OP_POW;

return-type ::= (OP_ARROW1|COLON) type-expression;
block-body  ::= BRACE_L block-statement* BRACE_R;
block-bare  ::= block-statement*;
// === localize path ===
localize-call ::= OP_L10N (identifier ((DOT|NAME_SPLIT|OP_DIV) identifier)*)? argument-body? {
    pin = 1
    mixin = "valkyrie.psi.mixin.MixinLocalize"
}
// === function call statement ===
function-call ::= namepath generic-call? (argument-body? block-body | argument-body);
function-call-inline ::= namepath argument-body;
dot-call        ::= OP_AND_THEN? DOT namepath (argument-body | argument-body? block-body)?;
dot-call-inline ::= OP_AND_THEN? DOT namepath argument-body?
// === macro call statement ===
macro-call    ::= OP_MACRO macro-path generic-call? (argument-body? class-body|argument-body)? {
    pin = 1
}
macro-path ::= identifier-free (NAME_SPLIT identifier-free)* {
    extends = namepath
}
dot-call-macro        ::= OP_AND_THEN? DOT OP_MACRO namepath (argument-body? class-body|argument-body)?
macro-call-inline     ::= OP_MACRO namepath argument-body?
dot-call-macro-inline ::= OP_AND_THEN? DOT OP_MACRO namepath argument-body?



// === if statement ===
if-statement ::= if-condition block-body else-if-statement* else-statement? {

}
if-condition ::= KW_IF expression-inline {
    pin = 1
}
else-if-statement ::= KW_ELSE KW_IF expression-inline block-body {
    pin = 2
}
then-statement ::= KW_THEN block-body {
    pin = 1
}
else-statement ::= KW_ELSE block-body {
    pin = 1
}
// === while statement ===
loop-statement ::= loop-start block-body else-statement? {

}
loop-template ::= TEMPLATE_L loop-start TEMPLATE_R statements* (template-else statements*)? template-end {

}
loop-start     ::= (KW_LOOP|KW_FOR) loop-condition? control-label? attribute-below* {
    pin = 1
}
loop-condition ::=
      loop-while-let // loop while let Some(value) = ... if ...
    | loop-while     // loop while {...}
    | loop-until-not // loop until not Integer = ... if ...
    | loop-until     // loop until {...}
    | loop-match     // loop match { case ... }
    | loop-each      // loop each x in ...
loop-while-let ::= KW_WHILE KW_LET? let-pattern type-hint? EQUAL expression-inline if-condition? {
    pin = 5
}
loop-while     ::= KW_WHILE expression-inline {
    pin = 1
}
loop-until-not ::= KW_UNTIL KW_NOT? type-pattern EQUAL expression-inline {
    pin = 4
}
loop-until     ::= KW_UNTIL expression-inline {
    pin = 1
}
loop-match     ::= KW_MATCH expression-inline {
    pin = 1
}
loop-each      ::= KW_EACH? match-bind? (bare-pattern !(PARENTHESIS_L|BRACKET_L|BRACE_L)|case-pattern) KW_IN expression-inline if-condition? {
    pin = 4
}

// === while statement ===
dot-loop-call  ::= OP_AND_THEN? DOT KW_LOOP control-label? attribute-below* KW_EACH? loop-inline? if-condition? block-body {
    pin = 3
}
loop-inline ::= bare-pattern !(PARENTHESIS_L|BRACKET_L|BIND)
    | match-bind? case-pattern-list   // loop x <- Some() in ...
    | match-bind? namepath            // loop x <- Option::None in ...
    | match-bind? special             // loop ture in ...
    | match-bind? string              // loop x <- "text" in ...
    | match-bind? number-literal      // loop x <- 1 in ...
// === function statement ===
let-statement ::= KW_LET let-pattern type-hint? EQUAL expression {
    pin = 4
    mixin = "valkyrie.psi.mixin.MixinVariable"
}
let-pattern ::= bare-pattern !let-stop // let ref x, mut y
    | match-bind? case-pattern-dict    // let a <- Object {x, y}
    | match-bind? case-pattern-list    // let a <- Some(x)
private let-stop ::= PARENTHESIS_L|BRACKET_L | BRACE_L | BIND;
// === try let statement ===
may-let-statement ::= KW_LET let-pattern type-hint? OP_SET_THEN expression {
    pin = 4
}
// === try statement ===
try-statement ::= KW_TRY type-expression? block-body {
    pin = 1
}
try-let-statement ::= KW_TRY KW_LET let-pattern type-hint? EQUAL expression if-condition? else-statement {
    pin = 2
}
try-not-statement ::= KW_TRY KW_NOT type-pattern EQUAL expression block-body then-statement {
    pin = 2
}
// === match statement ===
match-statement ::= match-kind match-bind? expression-inline? match-body {
    pin = 1
    mixin = "valkyrie.psi.mixin.MixinMatchStatement"
}
dot-match-call ::= OP_AND_THEN? DOT match-kind (modifier* identifier BIND)? match-body {
    pin = 3
    mixin = "valkyrie.psi.mixin.MixinMatchCall"
}
match-bind ::= modifier* identifier BIND
match-kind ::= KW_MATCH|KW_CATCH;
match-body ::= BRACE_L match-item* BRACE_R;
private match-item ::=
      match-with
    | match-type
    | match-case
    | match-when
    | match-else
match-with ::= KW_WITH (match-with-provide|match-with-control) {
    pin = 1
    recoverWhile=match-recover
}
match-with-provide ::= BRACKET_L     (type-expression (COMMA type-expression)? COMMA?)? BRACKET_R
match-with-control ::= PARENTHESIS_L (identifier-free (COMMA identifier-free)? COMMA?)? PARENTHESIS_R

match-type ::= KW_TYPE OP_OR? type-pattern (OP_OR type-pattern)* (COLON|KW_THEN) block-bare {
    pin = 1
    recoverWhile=match-recover
}
match-case ::= KW_CASE match-case-head match-case-rest* if-condition? (COLON|KW_THEN) block-bare {
    pin = 1
    recoverWhile=match-recover
}
private match-case-head ::= case-pattern-kind? case-pattern-top
private match-case-rest ::= case-pattern-kind  case-pattern-top
match-when ::= KW_WHEN infix-logical? expression (COLON|KW_THEN) block-bare {
    pin = 1
    recoverWhile=match-recover
}
match-else ::= KW_ELSE (COLON|KW_THEN) block-bare {
    pin = 1
    recoverWhile=match-recover
}
private match-recover ::= !(KW_WITH | KW_TYPE | KW_CASE | KW_WHEN | KW_ELSE | BRACE_R);
// === pattern expression ===
pattern ::=
      pattern-unapply
    | pattern-sequence
    | pattern-object
    | pattern-literal
pattern-unapply      ::= annotations namepath-auto? pattern-unapply-body;
pattern-unapply-body ::= PARENTHESIS_L (pattern (COMMA pattern)* COMMA?)? PARENTHESIS_R {
    pin = 1
}
pattern-sequence      ::= pattern-sequence-body;
pattern-sequence-body ::= BRACKET_L (pattern (COMMA pattern)* COMMA?)? BRACKET_R {
    pin = 1
}
pattern-object      ::= annotations namepath-auto? pattern-object-body;
pattern-object-body ::= BRACE_L (pattern-pair (COMMA pattern-pair)* COMMA?)? BRACE_R {
    pin = 1
}
pattern-pair    ::= annotations identifier (COLON pattern)?;
pattern-literal ::= annotations pattern-atomic
pattern-atomic  ::= string | number-literal | special | identifier;
// === is pattern ===
type-pattern ::= special
    | type-pattern-object // X is Object { a: _ }
    | type-pattern-tuple  // X is Tuple()
    | string              // X is "string"
    | number-literal              // X is 1
    | type-pattern-item   // X is Integer
type-pattern-inline ::= special
    | type-pattern-tuple  // X is Tuple()
    | string              // X is "string"
    | number-literal              // X is 1
    | type-pattern-item   // X is Integer
type-pattern-object ::= namepath? BRACE_L (type-pattern-pair (COMMA type-pattern-pair)* COMMA?)? BRACE_R
type-pattern-tuple  ::= namepath? PARENTHESIS_L (type-pattern (COMMA type-pattern)* COMMA?)? PARENTHESIS_R
                      | namepath? BRACKET_L     (type-pattern (COMMA type-pattern)* COMMA?)? BRACKET_R
type-pattern-pair   ::= identifier (EQUAL|COLON) type-pattern
type-pattern-item   ::= namepath generic-call-free?
// === case pattern ===
case-pattern ::= special
    | case-pattern-list    // case Some()
    | case-pattern-dict    // case Object { }
    | string               // case "text"
    | number-literal       // case 1
    | namepath
case-pattern-dict ::= namepath? BRACE_L (case-pattern-pair (COMMA case-pattern-pair)* COMMA?)? BRACE_R
case-pattern-pair ::= modifier* identifier (COLON type-expression)? (case-pattern-bind case-pattern)? {
    mixin = "valkyrie.psi.mixin.MixinCasePatternPair"
}
case-pattern-bind ::= EQUAL | OP_MACRO | BIND;
case-pattern-list ::= namepath? PARENTHESIS_L (case-pattern-main (COMMA case-pattern-main)* COMMA?)? PARENTHESIS_R
                    | namepath? BRACKET_L     (case-pattern-main (COMMA case-pattern-main)* COMMA?)? BRACKET_R
case-pattern-top  ::= modifier* identifier !case-id-stop (KW_IS type-expression)? (case-pattern-bind case-pattern)? | case-pattern {
    mixin = "valkyrie.psi.mixin.MixinCasePatternItem"
}
case-pattern-item ::= modifier* identifier !case-id-stop ((COLON|KW_IS) type-expression)? (case-pattern-bind case-pattern)? | case-pattern {
    mixin = "valkyrie.psi.mixin.MixinCasePatternItem"
}
case-pattern-main ::= case-pattern-kind? case-pattern-item case-pattern-rest*
case-pattern-rest ::= case-pattern-kind case-pattern-item
case-pattern-kind ::= OP_OR|OP_AND|LOGIC_AND|LOGIC_OR
private case-id-stop ::= NAME_SPLIT|PARENTHESIS_L|BRACE_L|BRACKET_L;
// === loop bare pattern pattern ===
bare-pattern      ::= bare-pattern-item (COMMA bare-pattern-item)* COMMA?
bare-pattern-item ::= modifier* identifier {
    mixin = "valkyrie.psi.mixin.MixinLetPatternItem"
}
// === new expression ===
// new f() { }
new-value  ::= annotations new-navigate type-expression? argument-body? new-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinBuilder"
}
new-navigate    ::= KW_NEW;
new-body ::= BRACE_L new-item* BRACE_R;
private new-item ::= SEMICOLON | COMMA
    | expression-root
// === object expression ===
// object: Interface { }
new-object ::= annotations object-navigate class-inherit? type-hint? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinObject"
}
object-navigate ::= KW_OBJECT;
// === lambda expression ===
// lambda<T>(x, y) -> T { }
new-lambda ::= annotations lambda-navigate declare-infer? parameter-body return-type? block-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinLambda"
}
lambda-navigate ::= KW_LAMBDA;
// === slot statement ===
slot ::=
    slot-named
  | slot-index
  | slot-first
slot-named ::= DOLLAR identifier;
slot-index ::= DOLLAR INTEGER;
slot-first ::= DOLLAR;
// === control expression ===
control-statement ::=
      control-return
    | control-yield-send    // generator<Yield=T, Return=()>
    | control-yield-stop    // generator<Yield=R, Return=()>
    | control-yield-from
    | control-continue
    | control-break
    | control-through
    | control-resume
control-break  ::= KW_BREAK control-label?
control-return ::= KW_RETURN control-label? expression-root?;
control-continue ::= KW_CONTINUE control-label?

control-yield-send ::=
    KW_YIELD KW_WITH KW_CONTINUE? expression-root
  | KW_YIELD KW_CONTINUE? control-label? expression-root
control-yield-stop ::=
    KW_YIELD KW_WITH KW_RETURN expression-root?
  | KW_YIELD KW_WITH KW_BREAK expression-root?
  | KW_YIELD KW_RETURN control-label? expression-root?
  | KW_YIELD KW_BREAK control-label? expression-root?
control-yield-from ::=
    KW_YIELD KW_WITH KW_FROM expression-root
  | KW_YIELD KW_FROM control-label? expression-root;
control-yield-type ::=
    KW_YIELD KW_WITH KW_TYPE type-expression?
  | KW_YIELD KW_TYPE control-label? type-expression?;
control-label ::= OP_LABEL (SYMBOL|SYMBOL_RAW|INTEGER|KW_MACRO|KW_FOR|KW_WHILE);
control-raise ::= KW_RAISE expression-root
    | KW_RAISE KW_USING expression-root
    | KW_RAISE KW_TYPE type-expression
control-resume ::= KW_RESUME control-label? expression-root
control-through ::= KW_THROUGH control-label?
// === common expression ===
expression-root ::= expression OP_AND_THEN? SEMICOLON? {

};
expression ::= term (infix term)*;
term ::= prefix* atomic suffix* {

}
// prefix operators
prefix ::= OP_ADD
    | OP_SUB
    | OP_SQRT
    | OP_SURD3
    | OP_SURD4
    | prefix-not
    | prefix-ref   // &p
    | prefix-deref // *p
    | ANY_LIST     // ..
    | ANY_DICT     // ...
// pointer prefix
prefix-ref   ::= OP_REFERENCE | OP_AND
prefix-deref ::= OP_DEREFERENCE | STAR
prefix-not   ::= OP_NOT | OP_BANG
// infix operators
infix  ::= OP_ADD  | OP_ADD_ASSIGN
    | OP_SUB | OP_SUB_ASSIGN
    | OP_OR
    | OP_AND
    | infix-multiple | OP_MUL_ASSIGN
    | OP_DIV | OP_DIV_ASSIGN
    | OP_DIV_ROUND
    | OP_DIV_FLOOR
    | OP_DIV_CEIL
    | OP_DIV_REM
    | OP_REM | OP_REM_ASSIGN
    | OP_POW
    | OP_SQRT
    | OP_LLL | bad-lll  // <<<
    | OP_GGG | bad-rrr  // >>>
    | OP_LL  | bad-ll   // <<
    | OP_GG  | bad-rr   // >>
    // compare
    | infix-less           // <
    | infix-less-equal     // <=
    | infix-greater        // >
    | infix-greater-equal  // >=
    // range
    | OP_UNTIL
    | EQUAL | OP_EE | OP_NE
    | infix-logical
    // sequence
    | OP_MAP // f /@ x
    | OP_UNWRAP_OR | OP_UNWRAP_ELSE // ??
infix-less          ::= ANGLE_L;
infix-less-equal    ::= OP_LEQ;
infix-greater       ::= ANGLE_R;
infix-greater-equal ::= OP_GEQ;
infix-logical       ::= LOGIC_AND | LOGIC_XAND | LOGIC_NAND | LOGIC_OR | LOGIC_XOR | LOGIC_NOR;
infix-multiple      ::= OP_MUL | STAR;
bad-lll ::= ANGLE_L ANGLE_L ANGLE_L
    | OP_LL ANGLE_L
    | ANGLE_L OP_LL
bad-rrr ::= ANGLE_R ANGLE_R ANGLE_R
    | OP_RR ANGLE_R
    | ANGLE_R OP_RR
bad-ll  ::= ANGLE_L ANGLE_L
bad-rr  ::= ANGLE_R ANGLE_R

suffix ::= OP_BANG
    | OP_CELSIUS
    | OP_FAHRENHEIT
    | dot-call-macro         // .@macro() { }
    | dot-call               // .method
    | dot-loop-call          // .loop { }
    | dot-match-call         // .match { }
    | KW_AS type-expression
    | is-statement
    | generic-call
    | ordinal-slice
    | offset-slice
is-statement ::= (KW_IS KW_NOT | OP_BANG KW_IS | KW_IS) type-pattern
is-expression ::= (KW_IS KW_NOT | OP_BANG KW_IS | KW_IS) type-pattern-inline
inline-suffix ::= OP_BANG
    | OP_CELSIUS
    | OP_FAHRENHEIT
    | dot-call-macro-inline  // .@macro
    | dot-call-inline        // .@function
    | is-expression
    | generic-call
    | ordinal-slice
    | offset-slice
// === inline expression statement ===
expression-inline ::= inline-term (infix inline-term)* {

};
inline-term ::= prefix* inline-atomic inline-suffix* {

}
inline-atomic ::= PARENTHESIS_L expression-root PARENTHESIS_R
    | TEMPLATE_L expression-root TEMPLATE_R
    | FLOOR_L expression-root FLOOR_R // ⌊5/2.0⌋
    | FLOOR_L expression-root CEIL_R  // ⌊5/2.0⌉
    | CEIL_L expression-root FLOOR_R  // ⌈5/2.0⌋
    | CEIL_L expression-root CEIL_R   // ⌈5/2.0⌉
    | tuple                 // (1, 2, 3)
    | macro-call-inline     // @macro()
    | offset-range          // ⁅1:2:3⁆
    | ordinal-range         // [1:2:3]
    | number-literal        // 1
    | string                // "text"
    | special               // true, false, null, ...
    | function-call-inline  // function()
    | namepath              // Option::None
// === expression statement ===
type-expression ::= type-term (type-infix type-term)* {
    mixin = "valkyrie.psi.mixin.MixinTypeExpression"
};
type-term ::= type-prefix* type-atomic type-suffix* {

}
type-prefix ::= OP_ADD | OP_SUB | OP_BANG | OP_AND | STAR;
type-infix  ::= OP_ADD | OP_ARROW1 | OP_OR | OP_MUL | OP_DIV ;
type-suffix ::= OP_AND_THEN
    | generic-call-free;
type-atomic ::= PARENTHESIS_L type-expression PARENTHESIS_R
    | type-tuple
    | namepath
    | number-literal
    | string
type-tuple  ::= PARENTHESIS_L PARENTHESIS_R
    | PARENTHESIS_L generic-argument COMMA PARENTHESIS_R
    | PARENTHESIS_L generic-argument (COMMA generic-argument)+ COMMA? PARENTHESIS_R;
// === generic statement ===
generic-call ::=
    NAME_SPLIT? GENERIC_L (generic-argument (COMMA generic-argument)* COMMA?)? GENERIC_R
  | NAME_SPLIT  ANGLE_L   (generic-argument (COMMA generic-argument)* COMMA?)? ANGLE_R
generic-call-free ::=
    NAME_SPLIT? GENERIC_L (generic-argument (COMMA generic-argument)* COMMA?)? GENERIC_R
  | NAME_SPLIT? ANGLE_L   (generic-argument (COMMA generic-argument)* COMMA?)? ANGLE_R
generic-argument ::=
      annotations identifier COLON type-expression EQUAL type-expression
    | annotations identifier COLON type-expression
    | annotations identifier EQUAL type-expression
    | type-expression;
// === atomic statement ===
atomic ::=    PARENTHESIS_L expression-root PARENTHESIS_R
    | TEMPLATE_L expression-root TEMPLATE_R
    | FLOOR_L expression-root FLOOR_R // ⌊5/2.0⌋
    | FLOOR_L expression-root CEIL_R  // ⌊5/2.0⌉
    | CEIL_L expression-root FLOOR_R  // ⌈5/2.0⌋
    | CEIL_L expression-root CEIL_R   // ⌈5/2.0⌉
    | tuple               // ( )
    | offset-range        // ⁅ ⁆
    | ordinal-range       // [ ]
    | macro-call          // @path::id() { }
    | slot                // $id
    | localize-call       // ⸿scope.path
    | if-statement        // if ...
    | loop-statement      // loop {...}
    | loop-template       // <% loop ... %> <% end %>
    | control-yield-type  // yield type i32
    | may-let-statement   // let? Some(x) = X
    | try-let-statement   // if case ...
    | try-not-statement
    | try-statement       // try T {...}
    | control-raise       // raise T
    | match-statement     // match ... { ... }
    | new-value           // new T { ... }
    | new-object          // object(base): Interface { }
    | new-lambda          // lambda<T>(x, y) -> T
    | string              // handler"..."
    | special             // true false
    | function-call       // path::id() { }
    | namepath
    | number-literal
// === atomic statement ===
ordinal-range ::= BRACKET_L (range-item (COMMA range-item)* COMMA?)? BRACKET_R;
ordinal-slice ::= OP_AND_THEN? ordinal-range;
offset-range  ::= OFFSET_L  (range-item (COMMA range-item)* COMMA?)? OFFSET_R
    | NAME_SPLIT  BRACKET_L (range-item (COMMA range-item)* COMMA?)? BRACKET_R
offset-slice  ::= OP_AND_THEN? offset-range;
range-item ::=
    range-lower? COLON range-upper? COLON range-step?
  | range-lower? c2 range-upper?
  | range-lower? COLON range-upper?
  | range-index
range-lower ::= expression-root;
range-upper ::= expression-root;
range-step  ::= expression-root;
range-index ::= expression-root;
private c2  ::= NAME_SPLIT | COLON COLON;
tuple       ::=
    PARENTHESIS_L PARENTHESIS_R
  | PARENTHESIS_L argument COMMA PARENTHESIS_R
  | PARENTHESIS_L (argument (COMMA argument)+ COMMA?)? PARENTHESIS_R
{
  //    mixin = "valkyrie.psi.mixin.MixinTuple"
}
argument-body ::= PARENTHESIS_L (argument (COMMA argument)* COMMA?)? PARENTHESIS_R;
argument ::= (identifier EQUAL)? expression-root {

}
// === literal items ===
number-literal ::=
    DECIMAL (OP_EXPONENT NUMBER_EXPONENT)? NUMBER_SUFFIX?
  | INTEGER (OP_BASE NUMBER_BASE)? (OP_EXPONENT NUMBER_EXPONENT)? NUMBER_SUFFIX?
string ::= identifier? STRING_L STRING_TEXT* STRING_R {
    mixin = "valkyrie.psi.mixin.MixinString"
}
special ::= KW_NIL|KW_NULL|KW_BOOLEAN|COLOR;
// === annotation statement ===
annotations ::= attribute-below* modifier*
modifier    ::= (SYMBOL | SYMBOL_RAW) !modifier-stop {
    mixin = "valkyrie.psi.mixin.MixinModifier"
}
private modifier-stop ::= KW_IN | KW_IF
    | COMMA | EQUAL | BIND | COLON | SEMICOLON
    | NAME_SPLIT | DOT
    | PARENTHESIS_L | PARENTHESIS_R
    | BRACE_L | BRACE_R
    | BRACKET_L | BRACKET_R
    | ANGLE_L | ANGLE_R
    | GENERIC_L | GENERIC_R
// ↯attribute.kind::<Type>(arg) { domain }
attribute-below  ::= OP_MACRO_LOWER attribute-list {
    pin = 1
}
// ↯attribute.kind::<Type>(arg) { domain }
attribute-above  ::= OP_MACRO_UPPER attribute-list {
    pin = 1
}
attribute-list   ::= attribute-item
    | '[' attribute-item (',' attribute-item)* ','? ']'
attribute-item   ::= namepath-free (DOT identifier-free)? generic-call? argument-body? class-body? {
    mixin = "valkyrie.psi.mixin.MixinAttribute"
}
// === identifiers ===
namepath ::= identifier (NAME_SPLIT identifier-free)*
    | NAME_SCOPE NAME_SPLIT? identifier-free (NAME_SPLIT identifier-free)*
{
    mixin = "valkyrie.psi.mixin.MixinNamepath"
}
namepath-free ::= (NAME_SCOPE NAME_SPLIT?)? identifier-free (NAME_SPLIT identifier-free)* {
    mixin = "valkyrie.psi.mixin.MixinNamepath"
}
namepath-auto ::= identifier ((NAME_SPLIT|DOT) identifier)* {
    mixin = "valkyrie.psi.mixin.MixinNamepath"
}
identifier ::= symbol-safe | symbol {
    mixin = "valkyrie.psi.mixin.MixinIdentifier"
}
identifier-free ::=  symbol-lead | symbol-safe | symbol {
    mixin = "valkyrie.psi.mixin.MixinIdentifier"
}
private symbol      ::= SYMBOL | SYMBOL_RAW;
// context keywords
private symbol-safe ::= KW_FROM | KW_AS | KW_END;
// always keywords
private symbol-lead ::= KW_LET
    | KW_NAMESPACE
    | KW_TYPE
    | KW_CLASS | KW_TRAIT | KW_OBJECT
    | KW_CATCH | KW_MATCH | KW_CASE
    | KW_MICRO | KW_MEZZO | KW_MACRO
template-end  ::= TEMPLATE_L KW_END keywords? TEMPLATE_R | OP_END
template-else ::= TEMPLATE_L KW_ELSE keywords? TEMPLATE_R
keywords      ::= KW_LOOP | KW_IF
// === navigation ===
unused ::= BUILDER_L BUILDER_R DOMAIN_L DOMAIN_R OP_ARROW2 OP_ARROW3