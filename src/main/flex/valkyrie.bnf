{
    parserClass = "valkyrie.psi.parser.YggdrasilParser"
    parserUtilClass = "valkyrie.psi.ParserExtension"

    extends = "valkyrie.psi.ValkyrieElement"

    psiClassPrefix = "Valkyrie"
    psiImplClassSuffix = "Node"
    psiPackage = "valkyrie.psi.node"
    psiImplPackage = "valkyrie.psi.node"

    elementTypeHolderClass = "valkyrie.psi.ValkyrieTypes"
    elementTypeClass = "valkyrie.psi.ValkyrieElementType"
    tokenTypeClass = "valkyrie.psi.ValkyrieTokenType"

    psiImplUtilClass = "valkyrie.psi.node.YggdrasilPsiExtension"

    tokens = [
        // comment
        COMMENT_LINE = "Comment"
        COMMENT_BLOCK = "Comment Block"

        // literal
        URL = "Url"
        SYMBOL    = "Symbol"
        ESCAPED   = "\escaped"
        INTEGER   = "<<INTEGER>>"

        REFERENCE = "$Symbol"

        SELECTION_LINE = "SELECTION_LINE"


        KW_GRAMMAR = "grammar"
        KW_USING = "using"
        KW_GROUP = "group"
        KW_CLASS = "class"
        KW_UNION = "union"
        KW_CLIMB = "climb"
        KW_IMPORT = "import"
        KW_AS = "as"
        KW_MACRO = "macro"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ANGLE_L = '<'
        ANGLE_R = '>'
        OP_REMARK = '^'
        BIND = '='
        COLON = ':'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        OP_MANY = '*'
        AT = '@'
        TO = "->"
        HYPHEN = "-"
        SLASH = '/'
        OP_OR = '|'
        OP_CONCAT = '~'
        PLACE_HOLDER = "_"
//      SPACE='regexp:\s+'
//      ANY = 'regexp:.'

    ]
}

// https://github.com/bytecodealliance/fluent/blob/master/spec/fluent.ebnf
root ::= statements*
private statements ::=
    declare-namespace
  | using
  | type-alias
  | trait-alias
  | declare-flags
  | declare-enumerate
  | declare-unite
  | declare-class
  | declare-union
  | declare-trait
  | declare-imply
  | declare-function
  | declare-variable
  | if-case-statement
  | if-statement
  | while-statement
  | for-statement
  | try-statement
  | catch-statement
  | match-statement
  | new-value
  | new-object
  | new-lambda
  | expression
  | SEMICOLON
block-statement ::=
    declare-variable
  | inline-statement;
inline-statement ::=
    if-case-statement
  | if-statement
  | while-statement
  | for-statement
  | try-statement
  | catch-statement
  | match-statement
  | new-value
  | new-object
  | new-lambda
  | expression
  | SEMICOLON;
// === grammar statement ===
declare-namespace ::= annotations KW_NAMESPACE namepath-free {
	pin = 2
    mixin = "valkyrie.psi.mixin.MixinNamespace"
}
// === class statement ===
using ::= annotations KW_USING (using-body|using-term) {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinUsing"
}
using-term ::=
    using-any
  | using-alias
  | using-block
  | namepath-free
  | SEMICOLON
  | COMMA
using-any     ::= (namepath-free using-dot?) STAR using-exclude?
using-exclude ::= KW_EXCLUDE (identifier-free|BRACE_L (identifier-free (COMMA identifier-free)* COMMA?) BRACE_R)
using-block   ::= namepath-free using-dot? using-body
using-body    ::= BRACE_L using-term* BRACE_R;
using-alias   ::= identifier-free KW_AS identifier-free;
private using-dot ::= DOT|PROPORTION|SLASH
// === class statement ===
type-alias ::= annotations KW_TYPE identifier-free EQUAL type-expression {
    pin = 2
}
declare-class ::= annotations KW_CLASS identifier-free declare-generic? class-inherit-body? type-hint? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinClass"
    methods=[createLookup]
}
class-inherit-body ::= PARENTHESIS_L (class-inherit (COMMA class-inherit)? COMMA?)? PARENTHESIS_R;
class-inherit      ::= (annotations identifier-free EQUAL)? type-expression;
// === class body ===
class-body ::= BRACE_L class-item* BRACE_R;
class-item ::=
    declare-method
  | declare-field
  | SEMICOLON
  | COMMA

// === class field statement ===
declare-field ::= annotations identifier-free type-hint? default-value? {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinField"
}
type-hint     ::= COLON type-expression {
    mixin = "valkyrie.psi.mixin.MixinTypeHint"
}
default-value ::= EQUAL expression;
default-type  ::= EQUAL type-expression;
// === class method statement ===
declare-method ::= annotations identifier-free declare-generic? parameter-body return-type? effect-type? block-body? {
    mixin = "valkyrie.psi.mixin.MixinMethod"
}
// === union statement ===
declare-union ::= annotations KW_UNITE identifier-free class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinUnion"
    methods=[createLookup]
}
// === enumerate statement ===
declare-flags ::= annotations KW_FLAGS identifier-free enumerate-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinFlags"
    methods=[createLookup]
}
declare-enumerate ::= annotations KW_ENUMERATE identifier-free enumerate-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinEnumerate"
    methods=[createLookup]
}
enumerate-body ::= BRACE_L enumerate-item* BRACE_R;
enumerate-item ::=
    declare-semantic
  | SEMICOLON
  | COMMA
declare-semantic ::= annotations identifier-free default-value? {
    mixin = "valkyrie.psi.mixin.MixinSemantic"
}
// === union statement ===
declare-unite ::= annotations KW_UNITE identifier OP_REMARK? union-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinUnite"
    methods=[createLookup]
}
union-body ::= BRACE_L union-variant* BRACE_R;
union-variant ::= OP_OR expression tag-branch? {
    mixin = "valkyrie.psi.mixin.MixinUnionItem"
}
tag-branch ::= HASH identifier-free;
// === group statement ===
trait-alias ::= annotations KW_TRAIT identifier-free EQUAL type-expression {
    pin = 4
    mixin = "valkyrie.psi.mixin.MixinTraitAlias"
}
declare-trait ::= annotations KW_TRAIT identifier-free? type-hint? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinTrait"
    methods=[createLookup]
}
declare-imply ::= annotations KW_IMPLY identifier-free class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinImply"
}
// === generic statement ===
declare-generic ::=
    PROPORTION? GENERIC_L (generic-parameter (COMMA generic-parameter)* COMMA?) GENERIC_R
  | PROPORTION? ANGLE_L   (generic-parameter (COMMA generic-parameter)* COMMA?) ANGLE_R
{

}
generic-parameter ::= annotations identifier-free type-hint? default-type?;
/// === function definition ===
declare-function ::= annotations KW_FUNCTION declare-generic? identifier-free parameter-body return-type? effect-type? block-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinFunction"
    methods=[createLookup]
}
parameter-body ::= PARENTHESIS_L (parameter-item (COMMA parameter-item)* COMMA?)? PARENTHESIS_R;
parameter-item ::= identifier type-hint? default-value? {

}

return-type  ::= (OP_ARROW1|COLON) type-expression;
effect-type  ::= SLASH type-expression;
block-body ::= BRACE_L block-statement* BRACE_R;
block-bare ::= inline-statement*;
// === function statement ===
declare-variable ::= KW_LET pattern-bare type-hint? EQUAL inline-statement {
    pin = 1
//    mixin = "valkyrie.psi.mixin.MixinVariable"
}
// === function statement ===
function-call ::= namepath argument-body {
    pin = 2
}
macro-call    ::= AT namepath argument-body? {
    pin = 1
}
dot-call ::= OP_AND_THEN? DOT namepath argument-body?;
dot-call-match ::= OP_AND_THEN? DOT KW_MATCH match-body {
    pin = 3
}
dot-call-catch ::= OP_AND_THEN? DOT KW_CATCH match-body {
    pin = 3
}
// === if statement ===
if-case-statement ::= KW_IF (KW_LET|KW_CASE) pattern EQUAL inline-expression block-body {
    pin=2
}
if-statement ::= if-condition block-body else-if-statement* else-statement? {

}
if-condition ::= KW_IF inline-expression {
    pin = 1
}
else-if-statement ::= KW_ELSE KW_IF inline-expression block-body {
    pin = 2
}
else-statement ::= KW_ELSE block-body {
    pin = 1
}
otherwise-statement ::= otherwise-kind block-body {
    pin = 1
}
otherwise-kind      ::= KW_OTHERWISE|KW_ELSE;
// === if statement ===
while-statement ::= while-kind inline-expression block-body otherwise-statement? {
    pin = 1
}
while-kind ::= KW_WHILE|KW_UNTIL
for-statement ::= KW_FOR pattern-bare KW_IN inline-expression if-condition? block-body otherwise-statement? {
    pin = 1
}
// === if statement ===
try-statement ::= KW_TRY type-expression? block-body {
    pin = 1
}
catch-statement ::= KW_CATCH inline-expression match-body {
    pin = 1
}
match-statement ::= KW_MATCH inline-expression match-body {
    pin = 1
}
match-body ::= BRACE_L match-item* BRACE_R;
match-item ::=
    match-with
  | match-case
  | match-when
  | match-else
match-with ::= KW_WITH pattern COLON block-bare {
    pin = 1
}
match-case ::= KW_CASE pattern COLON block-bare {
    pin = 1
}
match-when ::= KW_WHEN inline-expression COLON block-bare {
    pin = 1
}
match-else ::= KW_ELSE inline-expression COLON block-bare {
    pin = 1
}

// === pattern expression ===
pattern ::=
    pattern-unapply
  | pattern-sequence
  | pattern-object
  | pattern-atomic
pattern-bare     ::=
    pattern-atomic (COMMA pattern-atomic)* COMMA? !(PARENTHESIS_L|BRACKET_L|BRACE_L)
  | pattern-unapply
  | pattern-sequence
  | pattern-object
pattern-unapply      ::= annotations namepath-free? pattern-unapply-body;
pattern-unapply-body ::= PARENTHESIS_L (pattern (COMMA pattern)* COMMA?)? PARENTHESIS_R {
    pin = 1
}
pattern-sequence      ::= pattern-sequence-body;
pattern-sequence-body ::= BRACKET_L (pattern (COMMA pattern)* COMMA?)? BRACKET_R {
    pin = 1
}
pattern-object      ::= annotations namepath-free? pattern-object-body;
pattern-object-body ::= BRACE_L (pattern-pair (COMMA pattern-pair)* COMMA?)? BRACE_R {
    pin = 1
}
pattern-pair   ::= annotations identifier-free COLON pattern;
pattern-atomic ::= annotations (identifier-free | number | string)
// === pattern expression ===
new-value  ::= KW_NEW type-expression;
new-object ::= KW_OBJECT type-hint?;
new-lambda ::= KW_LAMBDA;
// === control expression ===
control-statement ::=
    KW_RETURN | KW_RESUME | KW_CONTINUE | KW_BREAK | KW_YIELD | KW_THROUGH | KW_RAISE;



// === common expression ===
expression ::= term (infix term)* {

};
term ::= prefix* atomic suffix* {

}
prefix ::= OP_PLUS | OP_MINUS | OP_BANG;
infix  ::=
    OP_PLUS | OP_MINUS
  | ANGLE_L | ANGLE_R
  | OP_AND
  | OP_UNTIL
  | OP_EQ | OP_NE
  | KW_AS
  | is_not | KW_IS
is_not ::= KW_IS KW_NOT | OP_BANG KW_IS;
suffix ::= OP_BANG | OP_AND_THEN | dot-call | dot-call-catch | dot-call-match | generic-call;
// === expression statement ===
inline-expression ::= term (infix term)* {
    extends=expression
};

// === expression statement ===
type-expression ::= type-term (type-infix type-term)* {
    mixin = "valkyrie.psi.mixin.MixinTypeExpression"
    methods=[highlight_trait highlight_class]
};
type-term ::= type-prefix* type-atomic type-suffix* {

}
type-prefix ::= OP_PLUS | OP_MINUS | OP_BANG;
type-infix  ::= OP_PLUS | OP_ARROW1 | OP_OR;
type-suffix ::= OP_AND_THEN | generic-call-free;
type-atomic ::= namepath | string;
// === generic statement ===
generic-call ::= PROPORTION? generic-call-standard-body | PROPORTION generic-call-ascii-body {

}
generic-call-free ::= PROPORTION? generic-call-standard-body | PROPORTION? generic-call-ascii-body {
    extends=generic-call
}
generic-call-standard-body ::= GENERIC_L (generic-argument (COMMA generic-argument)* COMMA?)? GENERIC_R
generic-call-ascii-body    ::= ANGLE_L   (generic-argument (COMMA generic-argument)* COMMA?)? ANGLE_R
generic-argument ::= (annotations identifier-free EQUAL)? type-expression;
// === atomic statement ===
atomic ::=
    PARENTHESIS_L expression PARENTHESIS_R
  | macro-call
  | function-call
  | special
  | namepath
  | string
  | number
  | ordinal-range
  | offset-range
// === atomic statement ===
ordinal-range ::= BRACE_L (range-item (COMMA range-item)? COMMA?) BRACE_R;
offset-range  ::= OFFSET_L (range-item (COMMA range-item)? COMMA?) OFFSET_R;
range-item ::= range-index
             | range-lower COLON range-upper?
             | range-lower COLON COLON range-step?
             | range-lower COLON range-upper COLON range-step?
             | COLON range-upper?
             | COLON COLON range-step?
             | COLON range-upper COLON range-step?
range-lower ::= expression;
range-upper ::= expression;
range-step  ::= expression;
range-index ::= expression;

string ::= TEXT_SINGLE | TEXT_DOUBLE {
    mixin = "valkyrie.psi.mixin.MixinString"
}
// === atomic statement ===

tuple    ::= PARENTHESIS_L PARENTHESIS_R
  | PARENTHESIS_L argument COMMA PARENTHESIS_R
  | PARENTHESIS_L (argument (COMMA argument)+ COMMA?)? PARENTHESIS_R
{
  //    mixin = "valkyrie.psi.mixin.MixinTuple"
}
argument-body ::= PARENTHESIS_L (argument (COMMA argument)* COMMA?)? PARENTHESIS_R;
argument ::= (identifier-free EQUAL)? expression {

}
number ::= INTEGER {
//    mixin = "valkyrie.psi.mixin.MixinNumber"
}
special ::= KW_NULL | KW_NIL | KW_TRUE | KW_FALSE | COLOR;
// === annotation statement ===
annotations ::= attribute* modifier*
modifier    ::= identifier !modifier-stop {
    mixin = "valkyrie.psi.mixin.MixinModifier"
}
private modifier-stop ::= KW_IN
    | COMMA | COLON | PROPORTION | DOT | SEMICOLON | EQUAL
    | PARENTHESIS_L | PARENTHESIS_R
    | BRACE_L | BRACE_R
attribute   ::= HASH namepath argument-body? {
	pin = 1
    mixin = "valkyrie.psi.mixin.MixinAttribute"
    methods=[highlight]
}
// === identifiers ===
namepath      ::= identifier (PROPORTION identifier)* {
    mixin = "valkyrie.psi.mixin.MixinNamepath"
    methods=[highlight_fake]
}
namepath-free ::= identifier ((PROPORTION|DOT) identifier)* {
    extends = namepath
}
identifier           ::= SYMBOL | SYMBOW_RAW {
    mixin = "valkyrie.psi.mixin.MixinIdentifier"
    methods=[highlight]
}
identifier-free      ::= SYMBOL | SYMBOW_RAW | KW_MACRO | KW_CLASS | KW_UNION | KW_GROUP | KW_GRAMMAR | KW_IMPORT | KW_AS | KW_CLIMB {
    extends = identifier
}
