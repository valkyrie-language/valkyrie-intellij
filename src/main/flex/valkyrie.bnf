{
    parserClass = "valkyrie.psi.parser.YggdrasilParser"
    parserUtilClass = "valkyrie.psi.ParserExtension"

    extends = "valkyrie.psi.ValkyrieElement"

    psiClassPrefix = "Valkyrie"
    psiImplClassSuffix = "Node"
    psiPackage = "valkyrie.psi.node"
    psiImplPackage = "valkyrie.psi.node"

    elementTypeHolderClass = "valkyrie.psi.ValkyrieTypes"
    elementTypeClass = "valkyrie.psi.ValkyrieAST"
    tokenTypeClass = "valkyrie.psi.ValkyrieCST"

    psiImplUtilClass = "valkyrie.psi.node.YggdrasilPsiExtension"

    tokens = [
        // comment
        COMMENT_LINE = "Comment Line"
        COMMENT_BLOCK = "Comment Block"

        // literal
        SYMBOL    = "Symbol"
        ESCAPED   = "\escaped"
        INTEGER   = "<<INTEGER>>"

        REFERENCE = "$Symbol"

        SELECTION_LINE = "SELECTION_LINE"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        ANGLE_L = '<'
        ANGLE_R = '>'

        EQUAL = '='
        COLON = ':'
        NAME_SPLIT = '∷'
        SEMICOLON = ';'
        COMMA = ','
        DOLLAR = '$'
        DOT = '.'
        ANY_LIST = '‥'
        ANY_DICT = '…'

        OP_LLL = "⋘"
        OP_GGG = "⋙"
        OP_LL = "≪"
        OP_GG = "≫"
    ]
}


root ::= statements*
statements ::= declare-namespace
    | using-statement
    | declare-type
    | declare-flags
    | declare-enums
    | declare-unite
    | declare-class
    | declare-union
    | declare-trait
    | declare-imply
    | declare-function
    | declare-mezzo
    | declare-macro
    | declare-tests
    | declare-component
    | declare-singleton
    | declare-neural
    | block-statement
private block-statement ::= SEMICOLON
    | let-statement
    | attribute-above
    | control-statement
    | expression-root
// === grammar statement ===
declare-namespace ::= annotations KW_NAMESPACE namepath-auto {
	pin = 2
    mixin = "valkyrie.psi.mixin.MixinNamespace"
}
// === class statement ===
using-statement ::= annotations KW_USING (using-body|using-term) {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinUsing"
}
using-body    ::= <<brace using-term>>;
using-term ::= SEMICOLON
    | using-any      // using
    | using-alias    // using
    | using-block    // using
    | namepath-auto  // using
using-any     ::= (namepath-auto using-dot?) STAR using-exclude?
using-exclude ::= KW_EXCLUDE (identifier-safe| <<brace identifier-free>>)
using-block   ::= namepath-auto using-dot? using-body
using-alias   ::= identifier-safe KW_AS identifier-safe;
private using-dot ::= DOT|NAME_SPLIT|OP_DIV
// infer T { where T: Show }
// imply List<T> { show_list() }
declare-infer ::= annotations KW_INFER (identifier-safe (COMMA identifier-safe)* COMMA?)? infer-body {
    pin = 2
}
infer-body ::= <<brace infer-item>>;
infer-item ::= SEMICOLON
    | declare-where
// where T: Show, X: Show
declare-where   ::= KW_WHERE COLON? where-term* {
    pin = 1
}
where-term      ::= COMMA | SEMICOLON
    | where-condition;
where-condition ::= annotations type-term type-hint? default-type?;
// === type statement ===
declare-type ::= annotations KW_TYPE (type-alias|type-function) {
    pin = 2
}
// type A = B
type-alias   ::= identifier-safe declare-infer? EQUAL type-expression;
// type A() -> B { }
type-function ::= declare-infer? identifier-safe parameter-body return-type? block-body;
// === class statement ===
declare-class ::= declare-infer? annotations KW_CLASS identifier-safe declare-generic? class-inherit? type-hint? class-body {
    pin = 3
    mixin = "valkyrie.psi.mixin.MixinClass"
    methods = [getKeyword getSuperClasses getFields]
}
declare-component ::= annotations KW_COMPONENT identifier-safe declare-generic? class-inherit? type-hint? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinComponent"
    methods = [getKeyword]
}
declare-singleton ::= annotations KW_SINGLETON identifier-safe declare-generic? class-inherit? type-hint? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinSingleton"
    methods = [getKeyword]
}
declare-neural ::= annotations KW_NEURAL identifier-safe declare-generic? class-inherit? type-hint? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinNeural"
    methods = [getKeyword]
}
class-inherit ::= <<parenthesis inherit-item>>;
inherit-item  ::= (annotations identifier-safe COLON)? type-expression {
    mixin = "valkyrie.psi.mixin.MixinClassInherit"
}
// === class body ===
class-body ::= <<brace class-item>>;
private class-item ::= SEMICOLON
    | associated-type
    | declare-domain
    | declare-method
    | declare-field
// === class field statement ===
declare-field ::= annotations identifier-free type-hint? default-value? {
    mixin = "valkyrie.psi.mixin.MixinField"
}
type-hint     ::= COLON type-expression {
    mixin = "valkyrie.psi.mixin.MixinTypeHint"
}
default-value ::= EQUAL expression-root;
default-type  ::= EQUAL type-expression;
// === class method statement ===
declare-method ::= annotations KW_FUNCTION? identifier-free declare-infer? parameter-body return-type? block-body? {
    mixin = "valkyrie.psi.mixin.MixinMethod"
}
// === class domain statement ===
declare-domain ::= annotations identifier-safe class-body {
    mixin = "valkyrie.psi.mixin.MixinDomain"
}
// === union statement ===
declare-union ::= annotations KW_UNION identifier-safe class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinUnion"
}
// === flags statement ===
declare-flags ::= annotations KW_FLAGS identifier-free class-inherit? (EQUAL type-atomic)? flags-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinFlags"
    methods = [getKeyword]
}
flags-body ::= <<brace flags-item>>;
private flags-item ::= SEMICOLON
    | declare-method
    | declare-domain
    | declare-semantic
declare-semantic ::= annotations identifier-safe (EQUAL expression)? {
    mixin = "valkyrie.psi.mixin.MixinSemantic"
}
// === enums statement ===
declare-enums ::= annotations KW_ENUMERATE identifier-safe class-inherit? (EQUAL type-atomic)? flags-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinEnumerate"
    methods = [getKeyword]
}
// === union statement ===
declare-unite ::= declare-infer? annotations KW_UNITE identifier-safe declare-infer? unite-body {
    pin = 3
    mixin = "valkyrie.psi.mixin.MixinUnite"
    methods = [getKeyword]
}
unite-body ::= <<brace (declare-method|declare-variant)>>;
declare-variant ::= annotations identifier-safe class-body? {
    mixin = "valkyrie.psi.mixin.MixinVariant"
}
// === group statement ===
declare-trait ::= annotations KW_TRAIT identifier-safe (trait-alias|trait-define) {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinTrait"
    methods = [getKeyword]
}
/// trait A = C + D
trait-alias ::= EQUAL type-expression {
    pin = 1
//    mixin = "valkyrie.psi.mixin.MixinTraitAlias"
}
/// trait A: B { ... }
trait-define ::= type-hint? declare-infer? class-body {
//    pin = 2
//    mixin = "valkyrie.psi.mixin.MixinTraitAlias"
}
associated-type ::= annotations KW_TYPE identifier-safe (EQUAL type-expression)? {
    pin = 2
}
// impl trait for class
declare-imply ::= annotations KW_IMPLY declare-infer? (
    // impl class: trait
    namepath-safe generic-call-free? COLON type-expression
    // impl trait for class
  | type-expression KW_FOR namepath-safe generic-call-free?
) class-body
{
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinImply"
}
// === generic statement ===
declare-generic ::=
    NAME_SPLIT? <<generic generic-parameter>>
  | NAME_SPLIT? <<angle generic-parameter>>
{

}
generic-parameter ::= annotations identifier-safe type-hint? default-type? {
    mixin = "valkyrie.psi.mixin.MixinTypeParameter"
}
/// === term function definition ===
declare-function ::= annotations KW_MICRO declare-infer? identifier-safe parameter-body return-type? block-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinDeclareFunction"
}
/// === type function definition ===
declare-mezzo ::= annotations KW_MEZZO declare-infer? identifier-safe parameter-body return-type? block-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinDeclareMezzo"
}
/// === expression function definition ===
declare-macro ::= annotations KW_MACRO declare-infer? identifier-safe parameter-body return-type? block-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinDeclareMacro"
}
parameter-body ::= <<parenthesis parameter-term>>;
private parameter-term ::= ANGLE_L | ANGLE_R
    | parameter-dict
    | parameter-list
    | parameter-item
parameter-item ::= annotations parameter-kind? identifier-free type-hint? default-value? {
    mixin = "valkyrie.psi.mixin.MixinValueParameter"
}
parameter-list ::= annotations ANY_LIST identifier-free? type-hint? default-value? {

}
parameter-dict ::= annotations ANY_DICT identifier-free? type-hint? default-value? {

}
parameter-kind ::= OP_POW;

return-type ::= (OP_ARROW1|COLON) type-expression;
block-body  ::= <<brace block-statement>>;
block-bare  ::= block-statement*;
/// === tests and benchmark ===
declare-tests ::= annotations KW_TESTS identifier-free? tests-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinDeclareTests"
}
tests-body ::= <<brace (declare-tests|run-benchmark|run-test-cast)>>;
run-test-cast ::= annotations identifier-safe block-body;
run-benchmark ::= annotations identifier-safe argument-body benchmark-body {

}
benchmark-body ::= <<brace benchmark-unit>>;
benchmark-unit ::= identifier-free argument-body? new-body? {

}
// === localize path ===
localize-call ::= OP_L10N (identifier-safe ((DOT|NAME_SPLIT|OP_DIV) identifier-safe)*)? argument-body? {
    pin = 1
    mixin = "valkyrie.psi.mixin.MixinLocalize"
}
// === function call statement ===
function-call ::= namepath-safe generic-call? (argument-body? block-body | argument-body);
function-call-inline ::= namepath-safe argument-body;
dot-call        ::= OP_AND_THEN? DOT namepath-safe (argument-body | argument-body? block-body)?;
dot-call-inline ::= OP_AND_THEN? DOT namepath-safe argument-body?
// === macro call statement ===
macro-call    ::= OP_MACRO macro-path generic-call? (argument-body? class-body|argument-body)? {
    pin = 1
}
macro-path ::= identifier-free (NAME_SPLIT identifier-free)* {
    extends = namepath-safe
}
dot-call-macro        ::= OP_AND_THEN? DOT OP_MACRO namepath-safe (argument-body? class-body|argument-body)?
macro-call-inline     ::= OP_MACRO namepath-safe argument-body?
dot-call-macro-inline ::= OP_AND_THEN? DOT OP_MACRO namepath-safe argument-body?



// === if statement ===
if-statement ::= if-condition block-body else-if-statement* else-statement? {

}
if-condition ::= KW_IF expression-inline {
    pin = 1
}
else-if-statement ::= KW_ELSE KW_IF expression-inline block-body {
    pin = 2
}
then-statement ::= KW_THEN block-body {
    pin = 1
}
else-statement ::= KW_ELSE block-body {
    pin = 1
}
else-template ::= TEMPLATE_L KW_ELSE TEMPLATE_R statements* {
    pin = 2
}
// === while statement ===
loop-statement ::= (KW_LOOP|KW_FOR) loop-start block-body else-statement? {

}
loop-template ::= loop-template-start else-template? template-end {

}
loop-template-start ::= TEMPLATE_L (KW_LOOP|KW_FOR) loop-start TEMPLATE_R statements* {

}
loop-start ::= loop-condition? control-label? attribute-below*;
loop-condition ::=
      loop-while-let // loop while let Some(value) = ... if ...
    | loop-while     // loop while {...}
    | loop-until-not // loop until not Integer = ... if ...
    | loop-until     // loop until {...}
    | loop-match     // loop match { case ... }
    | loop-each      // loop each x in ...
loop-while-let ::= KW_WHILE KW_LET? let-pattern type-hint? EQUAL expression-inline if-condition? {
    pin = 5
}
loop-while     ::= KW_WHILE expression-inline {
    pin = 1
}
loop-until-not ::= KW_UNTIL KW_NOT? type-pattern EQUAL expression-inline if-condition? {
    pin = 4
}
loop-until     ::= KW_UNTIL expression-inline {
    pin = 1
}
loop-match     ::= KW_MATCH expression-inline {
    pin = 1
}
loop-each      ::= KW_EACH? match-bind? (bare-pattern !(PARENTHESIS_L|BRACKET_L|BRACE_L)|case-pattern) KW_IN expression-inline if-condition? {
    pin = 4
}

// === while statement ===
dot-loop-call  ::= OP_AND_THEN? DOT KW_LOOP control-label? attribute-below* KW_EACH? loop-inline? if-condition? block-body {
    pin = 3
}
loop-inline ::= bare-pattern !(PARENTHESIS_L|BRACKET_L|BIND)
    | match-bind? case-pattern-list   // loop x = Some(y) in ...
    | match-bind? namepath-safe       // loop x = Option::None in ...
    | match-bind? special             // loop x = ture in ...
    | match-bind? string              // loop x = "text" in ...
    | match-bind? number-literal      // loop x = 1 in ...
// === function statement ===
// let bind = pattern <- expression
let-statement ::= attribute-below* KW_LET let-lhs {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinVariable"
    methods = [getKeyword]
}
private let-lhs ::= let-pattern type-hint? (ASSIGN_L|BIND) expression {
    pin=3
}
let-pattern ::= KW_CASE? modifier* case-pattern-list
    | KW_CASE? modifier* case-pattern-dict  // let a Object {x, y}
    | bare-pattern       // let ref x, mut y
// === loop bare pattern pattern ===
bare-pattern      ::= bare-pattern-item (COMMA bare-pattern-item)* COMMA?
bare-pattern-item ::= modifier* identifier-safe {
    mixin = "valkyrie.psi.mixin.MixinLetPatternItem"
}
// === try let statement ===
may-let-statement ::= KW_LET let-pattern type-hint? OP_SET_THEN expression {
    pin = 4
}
// === try statement ===
try-statement ::= KW_TRY type-expression? block-body {
    pin = 1
}
try-let-statement ::= KW_TRY KW_LET let-pattern type-hint? ASSIGN_L expression if-condition? else-statement {
    pin = 2
}
try-not-statement ::= KW_TRY KW_NOT type-pattern ASSIGN_L expression block-body then-statement {
    pin = 2
}
// === match statement ===
match-statement ::= match-kind match-bind? expression-inline? match-body {
    pin = 1
    mixin = "valkyrie.psi.mixin.MixinMatchStatement"
}
dot-match-call ::= OP_AND_THEN? DOT match-kind (modifier* identifier-safe BIND)? match-body {
    pin = 3
    mixin = "valkyrie.psi.mixin.MixinMatchCall"
}
match-bind ::= modifier* identifier-safe BIND;
match-kind ::= KW_MATCH|KW_CATCH;
match-body ::= <<brace (match-item)>>;
private match-item ::=
      match-with
    | match-type
    | match-case
    | match-when
    | match-else
match-with ::= KW_WITH (match-with-provide|match-with-control) {
    pin = 1
    recoverWhile=match-recover
}
match-with-provide ::= <<bracket type-expression>>
match-with-control ::= <<parenthesis identifier-free>>
match-type ::= KW_TYPE OP_OR? type-pattern (OP_OR type-pattern)* (COLON|KW_THEN) block-bare {
    pin = 1
    recoverWhile=match-recover
}
match-case ::= KW_CASE match-case-head match-case-rest* if-condition? (COLON|KW_THEN) block-bare {
    pin = 1
    recoverWhile=match-recover
}
private match-case-head ::= case-pattern-kind? case-pattern-top
private match-case-rest ::= case-pattern-kind  case-pattern-top
match-when ::= KW_WHEN infix-logical? expression (COLON|KW_THEN) block-bare {
    pin = 1
    recoverWhile=match-recover
}
match-else ::= KW_ELSE (COLON|KW_THEN) block-bare {
    pin = 1
    recoverWhile=match-recover
}
private match-recover ::= !(KW_WITH | KW_TYPE | KW_CASE | KW_WHEN | KW_ELSE | BRACE_R);
// === is pattern ===
type-pattern ::= special
    | type-pattern-object // X is Object { a: _ }
    | type-pattern-tuple  // X is Tuple()
    | string              // X is "string"
    | number-literal              // X is 1
    | type-pattern-item   // X is Integer
type-pattern-inline ::= special
    | type-pattern-tuple  // X is Tuple()
    | string              // X is "string"
    | number-literal              // X is 1
    | type-pattern-item   // X is Integer
type-pattern-object ::= namepath-safe? <<brace type-pattern-pair>>
type-pattern-tuple  ::= namepath-safe? <<parenthesis type-pattern>>
                      | namepath-safe? <<bracket type-pattern>>
type-pattern-pair   ::= identifier-safe (BIND|COLON) type-pattern
type-pattern-item   ::= namepath-safe generic-call-free?
// === case pattern ===
case-pattern ::= special
    | case-pattern-list    // case Some()
    | case-pattern-dict    // case Object { }
    | string               // case "text"
    | number-literal       // case 1
    | namepath-safe
case-pattern-dict ::= namepath-safe? <<brace case-pattern-pair>>
case-pattern-pair ::= annotations (ANY_LIST|ANY_DICT)? identifier-safe (COLON type-expression)? (case-pattern-bind case-pattern)? {
    mixin = "valkyrie.psi.mixin.MixinCasePatternPair"
}
case-pattern-bind ::= ASSIGN_L | OP_MACRO | BIND;
case-pattern-list ::= <<bracket case-pattern-main>>
    | namepath-safe?  <<parenthesis case-pattern-main>>

case-pattern-top  ::= modifier* identifier-safe !case-id-stop (KW_IS type-expression)? (case-pattern-bind case-pattern)? | case-pattern {
    mixin = "valkyrie.psi.mixin.MixinCasePatternItem"
}
case-pattern-item ::= annotations (ANY_LIST|ANY_DICT)? identifier-safe !case-id-stop ((COLON|KW_IS) type-expression)? (case-pattern-bind case-pattern)? | case-pattern {
    mixin = "valkyrie.psi.mixin.MixinCasePatternItem"
}
case-pattern-main ::= case-pattern-kind? case-pattern-item case-pattern-rest*
case-pattern-rest ::= case-pattern-kind case-pattern-item
case-pattern-kind ::= OP_OR|OP_AND|LOGIC_AND|LOGIC_OR
private case-id-stop ::= NAME_SPLIT|PARENTHESIS_L|BRACE_L|BRACKET_L;
// === new expression ===
// new f() { }
new-value  ::= annotations KW_NEW type-expression? argument-body? new-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinBuilder"
    methods = [getKeyword]
}
new-body ::= <<brace (new-bind|expression-root)>>;
new-bind ::= identifier-safe BIND expression;
// === object expression ===
// object: Interface { }
new-object ::= annotations KW_OBJECT class-inherit? type-hint? class-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinObject"
    methods = [getKeyword]
}
// === lambda expression ===
// lambda<T>(x, y) -> T { }
new-lambda ::= annotations KW_LAMBDA declare-infer? parameter-body return-type? block-body {
    pin = 2
    mixin = "valkyrie.psi.mixin.MixinLambda"
    methods = [getKeyword]
}
// === slot statement ===
slot ::=
    slot-named
  | slot-index
  | slot-first
slot-named ::= DOLLAR identifier-safe;
slot-index ::= DOLLAR INTEGER;
slot-first ::= DOLLAR;
// === control expression ===
control-statement ::=
      control-return
    | control-yield-send    // generator<Yield=T, Return=()>
    | control-yield-stop    // generator<Yield=R, Return=()>
    | control-yield-from
    | control-continue
    | control-break
    | control-through
    | control-resume
control-break  ::= KW_BREAK control-label?
control-return ::= KW_RETURN control-label? expression-root?;
control-continue ::= KW_CONTINUE control-label?

control-yield-send ::=
    KW_YIELD KW_WITH KW_CONTINUE? expression-root
  | KW_YIELD KW_CONTINUE? control-label? expression-root
control-yield-stop ::=
    KW_YIELD KW_WITH KW_RETURN expression-root?
  | KW_YIELD KW_WITH KW_BREAK expression-root?
  | KW_YIELD KW_RETURN control-label? expression-root?
  | KW_YIELD KW_BREAK control-label? expression-root?
control-yield-from ::=
    KW_YIELD KW_WITH KW_FROM expression-root
  | KW_YIELD KW_FROM control-label? expression-root;
control-yield-type ::=
    KW_YIELD KW_WITH KW_TYPE type-expression?
  | KW_YIELD KW_TYPE control-label? type-expression?;
control-label ::= OP_LABEL (SYMBOL|SYMBOL_RAW|INTEGER|KW_MACRO|KW_FOR|KW_WHILE);
control-raise ::= KW_RAISE expression-root
    | KW_RAISE KW_USING expression-root
    | KW_RAISE KW_TYPE type-expression
control-resume ::= KW_RESUME control-label? expression-root
control-through ::= KW_THROUGH control-label?
// === common expression ===
expression-root ::= expression OP_AND_THEN? SEMICOLON? {

};
expression ::= term (infix term)* {
    mixin = "valkyrie.psi.mixin.MixinTermExpression"
}
term ::= prefix* atomic suffix* {

}
// prefix operators
prefix ::= OP_ADD
    | OP_SUB
    | OP_SQRT
    | OP_SURD3
    | OP_SURD4
    | prefix-not
    | prefix-ref   // &p
    | prefix-deref // *p
    | ANY_LIST     // ..
    | ANY_DICT     // ...
// pointer prefix
prefix-ref   ::= OP_REFERENCE | OP_AND
prefix-deref ::= OP_DEREFERENCE | STAR
prefix-not   ::= OP_NOT | OP_BANG
// infix operators
infix  ::= OP_ADD  | OP_ADD_ASSIGN
    | OP_SUB | OP_SUB_ASSIGN
    | OP_OR
    | OP_AND
    | infix-multiple | OP_MUL_ASSIGN
    | OP_DIV | OP_DIV_ASSIGN
    | OP_DIV_ROUND
    | OP_DIV_FLOOR
    | OP_DIV_CEIL
    | OP_DIV_REM
    | OP_REM | OP_REM_ASSIGN
    | OP_POW
    | OP_SQRT
    | OP_LLL | bad-lll  // <<<
    | OP_GGG | bad-rrr  // >>>
    | OP_LL  | bad-ll   // <<
    | OP_GG  | bad-rr   // >>
    // compare
    | infix-less           // <
    | infix-less-equal     // <=
    | infix-greater        // >
    | infix-greater-equal  // >=
    // range
    | OP_UNTIL
    | BIND | ASSIGN_L | ASSIGN_R
    | OP_EE | OP_NE
    | infix-logical
    // sequence
    | OP_MAP // f /@ x
    | OP_UNWRAP_OR | OP_UNWRAP_ELSE // ??
infix-less          ::= ANGLE_L;
infix-less-equal    ::= OP_LEQ;
infix-greater       ::= ANGLE_R;
infix-greater-equal ::= OP_GEQ;
infix-logical       ::= LOGIC_AND | LOGIC_XAND | LOGIC_NAND | LOGIC_OR | LOGIC_XOR | LOGIC_NOR;
infix-multiple      ::= OP_MUL | STAR;
bad-lll ::= ANGLE_L ANGLE_L ANGLE_L
    | OP_LL ANGLE_L
    | ANGLE_L OP_LL
bad-rrr ::= ANGLE_R ANGLE_R ANGLE_R
    | OP_RR ANGLE_R
    | ANGLE_R OP_RR
bad-ll  ::= ANGLE_L ANGLE_L
bad-rr  ::= ANGLE_R ANGLE_R

suffix ::= OP_BANG
    | OP_CELSIUS
    | OP_FAHRENHEIT
    | dot-call-macro         // .@macro() { }
    | dot-call               // .method
    | dot-loop-call          // .loop { }
    | dot-match-call         // .match { }
    | KW_AS type-expression
    | is-statement
    | generic-call
    | ordinal-slice
    | offset-slice
is-statement ::= (KW_IS KW_NOT | OP_BANG KW_IS | KW_IS) type-pattern
is-expression ::= (KW_IS KW_NOT | OP_BANG KW_IS | KW_IS) type-pattern-inline
inline-suffix ::= OP_BANG
    | OP_CELSIUS
    | OP_FAHRENHEIT
    | dot-call-macro-inline  // .@macro
    | dot-call-inline        // .@function
    | is-expression
    | generic-call
    | ordinal-slice
    | offset-slice
// === inline expression statement ===
expression-inline ::= inline-term (infix inline-term)* {
    mixin = "valkyrie.psi.mixin.MixinTermExpression"
};
inline-term ::= prefix* inline-atomic inline-suffix* {

}
inline-atomic ::= PARENTHESIS_L expression-root PARENTHESIS_R
    | TEMPLATE_L expression-root TEMPLATE_R
    | FLOOR_L expression-root FLOOR_R // ⌊5/2.0⌋
    | FLOOR_L expression-root CEIL_R  // ⌊5/2.0⌉
    | CEIL_L expression-root FLOOR_R  // ⌈5/2.0⌋
    | CEIL_L expression-root CEIL_R   // ⌈5/2.0⌉
    | tuple                 // (1, 2, 3)
    | macro-call-inline     // @macro()
    | offset-range          // ⁅1:2:3⁆
    | ordinal-range         // [1:2:3]
    | number-literal        // 1
    | string                // "text"
    | special               // true, false, null, ...
    | function-call-inline  // function()
    | namepath-safe              // Option::None
// === expression statement ===
type-expression ::= type-term (type-infix type-term)* {
    mixin = "valkyrie.psi.mixin.MixinTypeExpression"
};
type-term ::= type-prefix* type-atomic type-suffix* {

}
type-prefix ::= OP_ADD | OP_SUB | OP_BANG | OP_AND | STAR;
type-infix  ::= OP_ADD | OP_ARROW1 | OP_OR | OP_MUL | OP_DIV ;
type-suffix ::= OP_AND_THEN
    | generic-call-free;
type-atomic ::= PARENTHESIS_L type-expression PARENTHESIS_R
    | type-tuple
    | namepath-safe
    | number-literal
    | string
type-tuple  ::= PARENTHESIS_L PARENTHESIS_R
    | PARENTHESIS_L generic-argument COMMA PARENTHESIS_R
    | PARENTHESIS_L generic-argument (COMMA generic-argument)+ COMMA? PARENTHESIS_R;
// === generic statement ===
generic-call      ::= NAME_SPLIT? <<generic generic-argument>> | NAME_SPLIT  <<angle generic-argument>>
generic-call-free ::= NAME_SPLIT? <<generic generic-argument>> | NAME_SPLIT? <<angle generic-argument>>
generic-argument  ::=
      annotations identifier-safe COLON type-expression BIND type-expression
    | annotations identifier-safe COLON type-expression
    | annotations identifier-safe BIND type-expression
    | type-expression;
// === atomic statement ===
atomic ::=    PARENTHESIS_L expression-root PARENTHESIS_R
    | TEMPLATE_L expression-root TEMPLATE_R
    | FLOOR_L expression-root FLOOR_R // ⌊5/2.0⌋
    | FLOOR_L expression-root CEIL_R  // ⌊5/2.0⌉
    | CEIL_L expression-root FLOOR_R  // ⌈5/2.0⌋
    | CEIL_L expression-root CEIL_R   // ⌈5/2.0⌉
    | tuple               // ( )
    | offset-range        // ⁅ ⁆
    | ordinal-range       // [ ]
    | macro-call          // @path::id() { }
    | slot                // $id
    | localize-call       // ⸿scope.path
    | if-statement        // if ...
    | loop-template       // <% loop ... %> <% end %>
    | loop-statement      // loop {...}
    | control-yield-type  // yield type i32
    | may-let-statement   // let? Some(x) = X
    | try-let-statement   // if case ...
    | try-not-statement
    | try-statement       // try T {...}
    | control-raise       // raise T
    | match-statement     // match ... { ... }
    | new-value           // new T { ... }
    | new-object          // object(base): Interface { }
    | new-lambda          // lambda<T>(x, y) -> T
    | string              // handler"..."
    | special             // true false
    | function-call       // path::id() { }
    | namepath-safe
    | number-literal
// === atomic statement ===
ordinal-range ::= <<bracket range-item>>;
ordinal-slice ::= OP_AND_THEN? ordinal-range;
offset-range  ::= <<offset range-item>> | NAME_SPLIT <<bracket range-item>>
offset-slice  ::= OP_AND_THEN? offset-range;
range-item ::=
    range-lower? COLON range-upper? COLON range-step?
  | range-lower? c2 range-upper?
  | range-lower? COLON range-upper?
  | range-index
range-lower ::= expression-root;
range-upper ::= expression-root;
range-step  ::= expression-root;
range-index ::= expression-root;
private c2  ::= NAME_SPLIT | COLON COLON;
tuple       ::=
    PARENTHESIS_L PARENTHESIS_R
  | PARENTHESIS_L argument COMMA PARENTHESIS_R
  | PARENTHESIS_L (argument (COMMA argument)+ COMMA?)? PARENTHESIS_R
{
  //    mixin = "valkyrie.psi.mixin.MixinTuple"
}
argument-body ::= <<parenthesis argument>>;
argument ::= (identifier-safe BIND)? expression-root {

}
// === literal items ===
number-literal ::=
    DECIMAL (OP_EXPONENT NUMBER_EXPONENT)? NUMBER_SUFFIX?
  | INTEGER (OP_BASE NUMBER_BASE)? (OP_EXPONENT NUMBER_EXPONENT)? NUMBER_SUFFIX?
string ::= identifier-safe? STRING_L STRING_TEXT* STRING_R {
    mixin = "valkyrie.psi.mixin.MixinString"
}
special ::= KW_NIL|KW_NULL|KW_BOOLEAN|COLOR;
// === annotation statement ===
annotations ::= attribute-below* modifier*
modifier    ::= (SYMBOL | SYMBOL_RAW) !modifier-stop {
    mixin = "valkyrie.psi.mixin.MixinModifier"
}
private modifier-stop ::= KW_IN | KW_IF
    | COMMA | SEMICOLON
    | COLON | BIND
    | NAME_SPLIT | DOT
    | PARENTHESIS_L | PARENTHESIS_R
    | BRACE_L | BRACE_R
    | BRACKET_L | BRACKET_R
    | ANGLE_L | ANGLE_R
    | GENERIC_L | GENERIC_R
    | ASSIGN_L | ASSIGN_R
// ↯attribute.kind::<Type>(arg) { domain }
attribute-below  ::= OP_MACRO_LOWER attribute-list {
    pin = 1
}
// ↯attribute.kind::<Type>(arg) { domain }
attribute-above  ::= OP_MACRO_UPPER attribute-list {
    pin = 1
}
attribute-list   ::= attribute-item
    | '[' attribute-item (',' attribute-item)* ','? ']'
attribute-item   ::= namepath-free (DOT identifier-free)? generic-call? argument-body? class-body? {
    mixin = "valkyrie.psi.mixin.MixinAttribute"
}
// === identifiers ===
namepath-safe ::= identifier-safe (NAME_SPLIT identifier-free)*
    | NAME_SCOPE NAME_SPLIT? identifier-free (NAME_SPLIT identifier-free)*
{
    mixin = "valkyrie.psi.mixin.MixinNamepath"
    methods=[getNamepath getNamespace getIdentifier highlight]
}
namepath-free ::= (NAME_SCOPE NAME_SPLIT?)? identifier-free (NAME_SPLIT identifier-free)* {
    mixin = "valkyrie.psi.mixin.MixinNamepath"
    methods=[getNamepath getNamespace getIdentifier highlight]
}
namepath-auto ::= identifier-safe ((NAME_SPLIT|DOT) identifier-safe)* {
    mixin = "valkyrie.psi.mixin.MixinNamepath"
    methods=[getNamepath getNamespace getIdentifier highlight]
}
identifier-safe ::= symbol-safe | symbol {
    mixin = "valkyrie.psi.mixin.MixinIdentifier"
}
identifier-free ::=  symbol-lead | symbol-safe | symbol {
    mixin = "valkyrie.psi.mixin.MixinIdentifier"
}
private symbol      ::= SYMBOL | SYMBOL_RAW;
// context keywords
private symbol-safe ::= KW_FROM | KW_AS;
// always keywords
private symbol-lead ::= KW_LET
    | KW_NAMESPACE
    | KW_TYPE
    | KW_CLASS | KW_TRAIT | KW_OBJECT
    | KW_CATCH | KW_MATCH | KW_CASE
    | KW_MICRO | KW_MEZZO | KW_MACRO
    | KW_IF | KW_ELSE
    | KW_LOOP | KW_FOR
template-end  ::= OP_END
    | TEMPLATE_L symbol-lead? KW_END TEMPLATE_R;
// === macros ===
private meta brace ::= BRACE_L (COMMA|SEMICOLON|<<term>>)* BRACE_R
private meta offset ::= OFFSET_L (<<term>> (COMMA <<term>>)* COMMA?)? OFFSET_R
private meta bracket ::= BRACKET_L (<<term>> (COMMA <<term>>)* COMMA?)? BRACKET_R
private meta parenthesis ::= PARENTHESIS_L (<<term>> (COMMA <<term>>)* COMMA?)? PARENTHESIS_R
private meta generic ::= GENERIC_L (<<term>> (COMMA <<term>>)* COMMA?)? GENERIC_R
private meta angle ::= ANGLE_L (<<term>> (COMMA <<term>>)* COMMA?)? ANGLE_R
// === navigation ===
unused ::= BUILDER_L BUILDER_R DOMAIN_L DOMAIN_R OP_ARROW2 OP_ARROW3