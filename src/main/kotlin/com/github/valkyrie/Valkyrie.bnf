{
    parserClass = "com.github.valkyrie.language.parser.ValkyrieParser"
    parserUtilClass = "com.github.valkyrie.language.psi.ValkyrieParserExtension"

    extends = "com.github.valkyrie.language.ast.ValkyrieASTBase"

    psiClassPrefix = "Valkyrie"
    psiImplClassSuffix = "Node"
    psiPackage = "com.github.valkyrie.language.psi"
    psiImplPackage = "com.github.valkyrie.language.psi_node"

    elementTypeHolderClass = "com.github.valkyrie.language.psi.ValkyrieTypes"
    elementTypeClass = "com.github.valkyrie.language.psi.ValkyrieTokenType"
    tokenTypeClass = "com.github.valkyrie.language.psi.ValkyrieTokenType"

    psiImplUtilClass = "com.github.valkyrie.language.ast.ASTMethods"
    generateTokenAccessors = false

    tokens = [
        COMMENT = "Comment"
        // literal
        SYMBOL_XID = "Symbol"
        SYMBOL_RAW = "Symbol"
        STRING_START = "StringStart"
        STRING_TEXT = "StringText"
        STRING_END = "StringEnd"
        BYTE = "Byte"

        DOT = '.'
        SEMICOLON = ';'
        COLON = ':'
        OP_PROPORTION = "::"

        OP_INC = "++"
        OP_ADD_ASSIGN = "+="
        OP_ADD = "+"
        OP_DEC = "--"
        OP_SUB_ASSIGN = "-="
        OP_SUB = "-"
        OP_MUL_ASSIGN = "*="
        OP_MUL = "*"
        OP_DIV_ASSIGN = "/="
        OP_DIV = "/"
        OP_MOD_ASSIGN = "%="
        OP_MOD = "%"

        OP_AND_ASSIGN = "&="
        OP_AND = "&"
        OP_AND2 = "&&"
        OP_OR_ASSIGN = "|="
        OP_OR = "|"
        OP_OR2 = "||"
        OP_POW = "^"
        // DOTS
        OP_ARROW = "->"
        OP_ARROW2 = "=>"
        //
        OP_EQ = "="
        OP_NE = "!="
        OP_BIND = ":="
        OP_NOT = "!"
        //
        OP_GT = ">"
        OP_GS = "/>"
        OP_GG = ">>"
        OP_GEQ = ">="
        OP_GGG = ">>>"
        //
        OP_LT = "<"
        OP_LS = "</"
        OP_LL = "<<"
        OP_LEQ = "<="
        OP_LLL = "<<<"
        OP_EMPTY = "(!)"

        OP_IS_A = "is"
        OP_NOT_A = "is not"

        OP_IN = "in"
        OP_NOT_IN = "not_in"
        OP_AND_THEN = "and_then"
        OP_OR_ELSE = "or_else"
        OP_FORALL = "forall"
        OP_EXISTS = "exists"

        PARENTHESIS_L = '('
        PARENTHESIS_R = ')'
        BRACKET_L = '['
        BRACKET_R = ']'
        BRACE_L = '{'
        BRACE_R = '}'
        SLICE_L = '[['
        SLICE_R = ']]'

        OP_NAMESAPCE = "namespace"

//        KW_NAMESPACE = "namespace"
//        KW_IMPORT = "using"
//        KW_EXTENSION = "extension"
//        KW_AS = "as"
//
//        KW_LET = "let"
//        KW_DEFINE = "def"
//        KW_NEW = 'new'
//
//        KW_IF = "if"
//        KW_ELSE = "else"
//        KW_FOR = "for"
//        KW_WHILE = "while"
//        KW_MATCH = 'match'
//        KW_CATCH = 'catch'
//
//        KW_CLASS = 'class'
//        KW_TRAIT = 'trait'
//        KW_TAGGED = 'tagged'
//        KW_BITFLAG = 'bitset'
//        KW_EXTENDS = 'extends'
    ]
}

valkyrie ::= ((top_statements|normal_statements) [SEMICOLON])*
private top_statements ::=
    namespace_statement
  | import_statement
  | extension_statement
  | class_statement
  | trait_statement
  | tagged_statement
  | bitflag_statement
  | extends_statement
  | define_statement
  ;
private normal_statements ::=
    if_statement
  | for_statement
  | while_statement
  | match_statement
  | let_statement
  | new_statement
  | type_statement
  | forall_statement
//  | macro_list
//  | macro_call
  | expression
  ;
// ---------------------------------------------------------------------------------------------------------------------
namespace_statement ::= kw_namespace namepath_free {
    mixin="com.github.valkyrie.language.mixin.MixinNamespace"
};
kw_namespace     ::= "namespace" | OP_NAMESAPCE {
    mixin="com.github.valkyrie.language.mixin.MixinKeyword"
}
// ---------------------------------------------------------------------------------------------------------------------
import_statement ::= kw_import (import_block|import_item) {
    mixin="com.github.valkyrie.language.mixin.MixinImport"
}
kw_import        ::= "using" | OP_IMPORT {
    mixin="com.github.valkyrie.language.mixin.MixinKeyword"
}
import_item      ::= namepath_free [OP_AS identifier|(DOT|OP_PROPORTION) import_block] {
    mixin="com.github.valkyrie.language.mixin.MixinImportItem"
}
import_block     ::= <<brace_block import_item COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
extension_statement ::= kw_extension identifier COLON namepath_free top_block {
    mixin="com.github.valkyrie.language.mixin.MixinExtension"
};
kw_extension      ::= "extension" | OP_EXTENSION {
    mixin="com.github.valkyrie.language.mixin.MixinKeyword"
}
top_block         ::= <<brace_block top_statements SEMICOLON>>
// ---------------------------------------------------------------------------------------------------------------------
if_statement      ::= (KW_IF condition block) [ef_statement* [else_statement]]
ef_statement      ::= kw_else_if condition block;
kw_else_if        ::= "else" KW_IF | "ef"
else_statement    ::= "else" block;
condition         ::= case_pattern OP_SET expression | expression;
case_pattern      ::= CASE [identifier* [namepath]] pattern;
private block     ::= <<brace_block expression SEMICOLON>>;
// ---------------------------------------------------------------------------------------------------------------------
for_statement     ::= KW_FOR (case_pattern|normal_pattern) KW_IF expression [if_guard] block [else_statement];
if_guard          ::= KW_IF condition;
normal_pattern    ::= identifier* pattern | <<sequence pattern_item COMMA>> {
    mixin="com.github.valkyrie.language.mixin.MixinNormalPattern"
};
// ---------------------------------------------------------------------------------------------------------------------
private pattern   ::=
    <<parenthesis   pattern_pair COMMA>>
  | <<bracket_block pattern_pair COMMA>>
  | <<brace_block   pattern_pair COMMA>>
  ;
pattern_pair      ::= identifier* COLON pattern_value | identifier* (DOT3|DOT2) identifier | identifier+;
pattern_item      ::= identifier* (DOT3|DOT2) identifier | identifier+;
pattern_value     ::= identifier | pattern;
// ---------------------------------------------------------------------------------------------------------------------
while_statement   ::= WHILE condition block;
// ---------------------------------------------------------------------------------------------------------------------
match_statement   ::= MATCH identifier* match_block;
match_block       ::= <<brace_block match_expression SEMICOLON>>;
match_expression  ::= case_pattern COLON (normal_statements [SEMICOLON])+
// ---------------------------------------------------------------------------------------------------------------------
define_statement  ::= kw_define [modifiers] namepath_free [generic_define] define_tuple [(COLON|OP_ARROW) type_expression] [define_block| OP_EQ expression] {
    mixin="com.github.valkyrie.language.mixin.MixinDefine"
};
kw_define         ::= "def" {
    mixin="com.github.valkyrie.language.mixin.MixinKeyword"
}
define_tuple      ::= <<parenthesis define_item COMMA>>;
define_item       ::= OP_POW | OP_LT | OP_GT
  | macro_call* [modifiers] [DOT2|DOT3] identifier [COLON type_expression] [OP_EQ expression] {
    mixin="com.github.valkyrie.language.mixin.MixinDefineItem"
}
define_block      ::= <<brace_block normal_statements SEMICOLON>>;
// ---------------------------------------------------------------------------------------------------------------------
let_statement     ::=
    LET normal_pattern [let_type_hint] [OP_SET expression]
  | LET case_pattern OP_SET expression;
let_type_hint     ::= COLON <<sequence type_expression COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
type_statement    ::= KW_TYPE identifier [[OP_PROPORTION] type_generic] [OP_SET type_expr] {
    mixin="com.github.valkyrie.language.mixin.MixinType"
};
generic_define    ::=
    <<bracket_block ([identifier COLON] type_expression) COMMA>>
  | OP_PROPORTION? <<angle_block ([identifier COLON] type_expression) COMMA>>
generic_call      ::=
    <<bracket_block ([identifier COLON] type_expression) COMMA>>
  | OP_PROPORTION <<angle_block ([identifier COLON] type_expression) COMMA>>
// ---------------------------------------------------------------------------------------------------------------------
forall_statement  ::= FORALL <<sequence identifier COMMA>> [forall_block];
forall_block      ::= <<brace_block (type_expression COLON type_expression) (COMMA|SEMICOLON)>>;
// ---------------------------------------------------------------------------------------------------------------------
class_statement   ::= kw_class [modifiers] identifier [generic_define] [class_inherit] [class_tuple|class_block] {
    mixin="com.github.valkyrie.language.mixin.MixinClass"
};
kw_class          ::= "class"|"struct" {
    mixin="com.github.valkyrie.language.mixin.MixinKeyword"
}
class_inherit     ::= COLON identifier [type_generic] (OP_ADD identifier)*;
class_tuple       ::= <<parenthesis class_item COMMA>> {
    mixin="com.github.valkyrie.language.mixin.MixinClassTuple"
}
class_block       ::= <<brace_free (class_define|class_item) (COMMA|SEMICOLON)>>
class_define      ::= identifier tuple [(COLON|OP_ARROW) type_expression] [object_block]
class_item        ::= [modifiers] object_key [COLON type_expression] [OP_SET expression] {

};
// ---------------------------------------------------------------------------------------------------------------------
object_block      ::= <<brace_free (object_define|object_item) (COMMA|SEMICOLON)>>
object_define     ::= identifier define_tuple [(COLON|OP_ARROW) type_expression] block {

};
object_item       ::= object_key COLON expression {

}
object_key        ::= SYMBOL_XID | SYMBOL_RAW | INTEGER | KW_IF {
    mixin="com.github.valkyrie.language.mixin.MixinIdentifier"
}
// ---------------------------------------------------------------------------------------------------------------------
trait_statement   ::= KW_TRAIT modifiers [type_generic] [COLON type_expression] trait_block {
    extends="com.github.valkyrie.language.mixin.MixinTrait"
};
trait_block       ::= <<brace_free top_statements SEMICOLON>>;
//trait_item        ::= normal_statements;
// ---------------------------------------------------------------------------------------------------------------------
extends_statement ::= kw_extends [type_generic] [modifiers] identifier [type_generic] [COLON type_expression] trait_block {
    extends="com.github.valkyrie.language.mixin.MixinExtends"
}
kw_extends        ::= "extends" | "extend" {
    mixin="com.github.valkyrie.language.mixin.MixinKeyword"
}
// ---------------------------------------------------------------------------------------------------------------------
tagged_statement  ::= TAGGED modifiers [[OP_PROPORTION] type_generic] tagged_block {
    mixin="com.github.valkyrie.language.mixin.MixinTagged"
};
tagged_block      ::= <<brace_block tagged_item (COMMA|SEMICOLON)>>;
tagged_item       ::= identifier [class_block|class_brace];
// ---------------------------------------------------------------------------------------------------------------------
bitflag_statement ::= BITFLAG modifiers [bitflag_layout] bitflag_block {
    mixin="com.github.valkyrie.language.mixin.MixinBitflag"
};
bitflag_block     ::= <<brace_block (bitflag_item | macro_call) SEMICOLON>>;
bitflag_layout    ::= PARENTHESIS_L type_expression PARENTHESIS_R;
bitflag_item      ::= identifier OP_SET expression;
// -------------- -------------------------------------------------------------------------------------------------------
new_statement     ::= NEW modifiers [type_generic] [COLON type_expression] trait_block;
// ---------------------------------------------------------------------------------------------------------------------
expression        ::= expr (op_binary expr)*;
private expr      ::= op_prefix* term (op_suffix|call_suffix|type_generic|slice)*;
private op_binary ::=
      OP_SET | OP_EQ | OP_NE
    | OP_ADD | OP_ADD_ASSIGN
    | OP_SUB | OP_SUB_ASSIGN
    | OP_MUL | OP_MUL_ASSIGN
    | OP_DIV | OP_DIV_ASSIGN | OP_MOD | OP_MOD_ASSIGN
    | OP_POW | OP_POW_ASSIGN
    | OP_GT | OP_LT | DOT_LESS | DOT_EQ | DOT2 | DOT
    | OP_TO
    | OP_AND_THEN | OP_OR_ELSE
    // is | is not
    | OP_NOT_A | OP_IS_A OP_NOT | OP_IS_A | OP_NOT OP_IS_A
    | OP_AS
    // in | not in
    | OP_IN | OP_NOT_IN | OP_NOT OP_IN
private op_prefix ::= OP_ADD | OP_SUB | OP_NOT | BANG | AMP | DOT3 | DOT2;
private op_suffix ::= BANG | QUESTION;
call_suffix       ::= <<parenthesis expression COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
type_expression   ::= type_expr (op_binary type_expr)*;
private type_expr ::= op_prefix* term (op_suffix|call_suffix|type_generic|slice)*;
type_generic      ::= <<bracket_block ([identifier COLON] type_expression) COMMA>>;
type_instance     ::= identifier type_generic?
// ---------------------------------------------------------------------------------------------------------------------
macro             ::= AT namepath_free;
// ---------------------------------------------------------------------------------------------------------------------
macro_call        ::= macro [macro_item];
macro_item        ::=
    <<parenthesis expression COMMA>>
  | <<brace_block pair COMMA>>
  | <<brace_block expression SEMICOLON>>;
macro_list ::= [AT|HASH] <<bracket_block (namepath macro_item) COMMA>>;
// ---------------------------------------------------------------------------------------------------------------------
private term   ::= range | list | tuple | atoms;
tuple          ::= <<parenthesis expression COMMA>>
list           ::= <<bracket_block expression COMMA>>
range          ::= <<slice_block slice_item COMMA>>;
slice          ::= <<slice_block slice_item COMMA>>;
slice_item     ::=
    [expression] COLON [expression] COLON [expression]
  | [expression] COLON [expression]
  | [expression] OP_PROPORTION [expression]
  | expression;
// ---------------------------------------------------------------------------------------------------------------------
private atoms  ::= number | string | boolean | namepath;
pair           ::= atoms COLON expression;
boolean        ::= "true" | "false";
number         ::= (BYTE | INTEGER | DECIMAL) [identifier] {
    mixin="com.github.valkyrie.language.mixin.MixinNumber"
}
string         ::= [identifier] STRING_START STRING_TEXT STRING_END {
    mixin="com.github.valkyrie.language.mixin.MixinString"
}
// ---------------------------------------------------------------------------------------------------------------------
namepath_free  ::= identifier ((DOT|OP_PROPORTION) identifier)* {
    mixin="com.github.valkyrie.language.mixin.MixinNamepath"
}
namepath       ::= identifier (OP_PROPORTION identifier)* {
    mixin="com.github.valkyrie.language.mixin.MixinNamepath"
}
identifier     ::= SYMBOL_XID | SYMBOL_RAW {
    mixin="com.github.valkyrie.language.mixin.MixinIdentifier"
}
modifiers      ::= (identifier !end_m1)+ {
    mixin="com.github.valkyrie.language.mixin.MixinModifier"
};
private end_m1 ::= (
    COLON|OP_PROPORTION|SEMICOLON|
    BRACKET_L|BRACKET_R|PARENTHESIS_L|PARENTHESIS_R|
    COMMA|OP_EQ|DOT
);
// ---------------------------------------------------------------------------------------------------------------------
private meta sequence      ::= <<item>> (<<sp>> <<item>>)* [<<sp>>];
// parenthesis ( )
private meta parenthesis   ::= PARENTHESIS_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] PARENTHESIS_R;
// bracket [ ]
private meta bracket_block ::= BRACKET_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACKET_R;
// brace { }
private meta brace_block   ::= BRACE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACE_R;
// brace { }
private meta brace_free    ::= BRACE_L (<<item>>|<<sp>>)* BRACE_R;
// angle ::< >::
private meta angle_block   ::= OP_LT [<<item>> (<<sp>> <<item>>)* [<<sp>>]] OP_GT;
// angle ⟦ ⟧
private meta slice_block   ::= SLICE_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] SLICE_R;